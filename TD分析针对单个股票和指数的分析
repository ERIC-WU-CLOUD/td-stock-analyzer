import tushare as ts
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import time
import warnings
import webbrowser
import os

# 在所有matplotlib导入之前添加这些行
import matplotlib

matplotlib.use('Agg')  # 使用非交互式后端，避免tkinter冲突

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.patches import Rectangle
import matplotlib.font_manager as fm
from scipy.signal import argrelextrema
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
import threading

warnings.filterwarnings('ignore')

# 设置matplotlib中文字体和样式
plt.rcParams['font.sans-serif'] = ['SimHei', 'DejaVu Sans', 'Arial Unicode MS', 'Helvetica']
plt.rcParams['axes.unicode_minus'] = False
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'

# 设置tushare token
TOKEN = '093ec10aeb924a25cf1b81915f855e8240629e5bb69597697face485'
ts.set_token(TOKEN)
pro = ts.pro_api(TOKEN)

# 线程锁用于API调用
api_lock = threading.Lock()


def check_trade_date(date_str):
    """检查输入的日期是否为交易日"""
    with api_lock:
        trade_cal = pro.trade_cal(exchange='SSE', start_date=date_str, end_date=date_str)
    if len(trade_cal) > 0 and trade_cal.iloc[0]['is_open'] == 1:
        return True
    return False


@lru_cache(maxsize=32)
def get_latest_trade_date():
    """获取最近的交易日（带缓存）"""
    today = datetime.now().strftime('%Y%m%d')
    with api_lock:
        trade_cal = pro.trade_cal(exchange='SSE', end_date=today, is_open=1)
    trade_cal = trade_cal.sort_values('cal_date', ascending=False)
    return trade_cal.iloc[0]['cal_date']


def get_previous_trade_date(date_str):
    """获取指定日期的前一个交易日"""
    with api_lock:
        trade_cal = pro.trade_cal(exchange='SSE', end_date=date_str, is_open=1)
    trade_cal = trade_cal.sort_values('cal_date', ascending=False)
    if len(trade_cal) >= 2:
        return trade_cal.iloc[1]['cal_date']
    return None


def get_next_60_trade_dates(start_date):
    """获取指定日期之后的60个交易日"""
    try:
        # 计算一个足够大的结束日期（大约3个月后）
        start_dt = pd.to_datetime(start_date)
        end_dt = start_dt + timedelta(days=120)  # 预留足够的天数
        end_date = end_dt.strftime('%Y%m%d')

        # 获取交易日历
        with api_lock:
            trade_cal = pro.trade_cal(exchange='SSE', start_date=start_date, end_date=end_date, is_open=1)
        trade_cal = trade_cal.sort_values('cal_date', ascending=True)

        # 排除起始日期，取后面的60个交易日
        future_dates = trade_cal[trade_cal['cal_date'] > start_date]

        if len(future_dates) >= 60:
            return future_dates.head(60)['cal_date'].tolist()
        else:
            return future_dates['cal_date'].tolist()
    except Exception as e:
        print(f"获取60个交易日出错: {e}")
        return []


def calculate_max_profit_after_target_date(stock_code, target_date):
    """
    计算目标日期之后60个交易日内的最大盈利百分比和天数
    使用前复权数据计算
    """
    try:
        # 获取目标日期之后的60个交易日
        future_trade_dates = get_next_60_trade_dates(target_date)

        if not future_trade_dates:
            return {'max_profit_pct': 0, 'max_profit_days': 0, 'status': '无未来数据'}

        # 获取目标日期的前复权收盘价
        try:
            with api_lock:
                target_data = pro.stk_factor_pro(**{
                    "ts_code": stock_code,
                    "start_date": target_date,
                    "end_date": target_date,
                    "trade_date": "",
                    "limit": "",
                    "offset": ""
                }, fields=["ts_code", "trade_date", "close_qfq"])

            if len(target_data) == 0:
                # 备用方案：使用普通接口
                with api_lock:
                    target_data = pro.daily(ts_code=stock_code, start_date=target_date, end_date=target_date)
                target_data['close_qfq'] = target_data['close']  # 简化处理
        except:
            # 备用方案
            with api_lock:
                target_data = pro.daily(ts_code=stock_code, start_date=target_date, end_date=target_date)
            target_data['close_qfq'] = target_data['close']

        if len(target_data) == 0:
            return {'max_profit_pct': 0, 'max_profit_days': 0, 'status': '目标日期无数据'}

        target_close_price = target_data.iloc[0]['close_qfq']

        # 获取60个交易日的数据
        start_future_date = future_trade_dates[0]
        end_future_date = future_trade_dates[-1]

        try:
            with api_lock:
                future_data = pro.stk_factor_pro(**{
                    "ts_code": stock_code,
                    "start_date": start_future_date,
                    "end_date": end_future_date,
                    "trade_date": "",
                    "limit": "",
                    "offset": ""
                }, fields=["ts_code", "trade_date", "high_qfq", "close_qfq"])

            if len(future_data) == 0:
                # 备用方案
                with api_lock:
                    future_data = pro.daily(ts_code=stock_code, start_date=start_future_date, end_date=end_future_date)
                future_data['high_qfq'] = future_data['high']
                future_data['close_qfq'] = future_data['close']
        except:
            # 备用方案
            with api_lock:
                future_data = pro.daily(ts_code=stock_code, start_date=start_future_date, end_date=end_future_date)
            future_data['high_qfq'] = future_data['high']
            future_data['close_qfq'] = future_data['close']

        if len(future_data) == 0:
            return {'max_profit_pct': 0, 'max_profit_days': 0, 'status': '未来期间无数据'}

        # 按日期排序
        future_data = future_data.sort_values('trade_date')

        # 计算每日的最大盈利
        max_profit_pct = 0
        max_profit_days = 0

        for idx, row in future_data.iterrows():
            # 使用当日最高价计算盈利
            current_profit = (row['high_qfq'] - target_close_price) / target_close_price * 100

            if current_profit > max_profit_pct:
                max_profit_pct = current_profit
                # 计算是第几个交易日（从1开始）
                current_date = row['trade_date']
                if current_date in future_trade_dates:
                    max_profit_days = future_trade_dates.index(current_date) + 1

        return {
            'max_profit_pct': round(max_profit_pct, 2),
            'max_profit_days': max_profit_days,
            'status': 'success',
            'actual_days_count': len(future_data)
        }

    except Exception as e:
        print(f"计算 {stock_code} 最大盈利时出错: {e}")
        return {'max_profit_pct': 0, 'max_profit_days': 0, 'status': f'计算出错: {str(e)}'}


# 情绪分析部分
# 优化后的情绪分析部分
def calculate_emotion_analysis(hist_data):
    """
    专业情绪分析 - 基于前复权数据 (优化版本)
    综合多个情绪指标：RSI、CCI、KDJ、MACD、PSY、VR等
    优化内容：
    1. 添加得分范围限制
    2. 优化权重分配
    3. 增加趋势分析
    4. 改进数据完整性检查
    """
    df = hist_data.copy().sort_values('trade_date')

    if len(df) < 20:
        return {
            'emotion_score': 50,  # 中性
            'emotion_level': '中性',
            'rsi_emotion': '数据不足',
            'cci_emotion': '数据不足',
            'kdj_emotion': '数据不足',
            'macd_emotion': '数据不足',
            'psy_emotion': '数据不足',
            'vr_emotion': '数据不足',
            'obv_emotion': '数据不足',
            'mfi_emotion': '数据不足',
            'emotion_analysis': '历史数据不足，无法进行有效的情绪分析',
            'emotion_signals': [],
            'emotion_warnings': [],
            'emotion_opportunities': [],
            'data_completeness': 0,
            'trend_analysis': {}
        }

    latest = df.iloc[-1]
    recent_5 = df.tail(5)
    recent_10 = df.tail(10)

    # 优化后的权重配置 - 确保总权重在±45分以内
    EMOTION_WEIGHTS = {
        'RSI': {'positive': 10, 'negative': 10},  # 核心指标，权重最高
        'CCI': {'positive': 6, 'negative': 6},  # 降低权重，避免与RSI重叠
        'KDJ': {'positive': 5, 'negative': 5},  # 短期指标
        'MACD': {'positive': 6, 'negative': 6},  # 趋势指标
        'PSY': {'positive': 4, 'negative': 4},  # 心理指标
        'VR': {'positive': 3, 'negative': 3},  # 成交量指标
        'OBV': {'positive': 5, 'negative': 5},  # 资金流向
        'MFI': {'positive': 3, 'negative': 3},  # 资金流量
        'VOLUME': {'positive': 3, 'negative': 3}  # 新增：成交量确认
    }
    # 总权重：45分，确保基础分50±45 = 5-95分

    # 优化后的阈值配置
    INDICATOR_THRESHOLDS = {
        'RSI': {'extreme_high': 85, 'high': 70, 'low': 30, 'extreme_low': 15},
        'CCI': {'extreme_high': 200, 'high': 100, 'low': -100, 'extreme_low': -200},
        'KDJ': {'high': 80, 'low': 20},
        'PSY': {'extreme_high': 80, 'high': 65, 'low': 35, 'extreme_low': 20},
        'VR': {'extreme_high': 350, 'high': 200, 'low': 80, 'extreme_low': 50},
        'MFI': {'high': 80, 'low': 20}
    }

    # 情绪得分累积器
    emotion_score = 50  # 基础分数（中性）
    emotion_signals = []
    emotion_warnings = []
    emotion_opportunities = []
    trend_analysis = {}

    # 数据完整性检查
    def check_data_availability(indicator_name, value):
        """检查指标数据可用性"""
        if pd.isna(value) or value == 0:
            return False, f"{indicator_name}数据缺失"
        return True, ""

    def analyze_indicator_trend(values, indicator_name, periods=3):
        """分析指标趋势"""
        if len(values) < periods:
            return 'insufficient_data', 0

        recent_values = values.tail(periods)
        if recent_values.isna().any():
            return 'data_missing', 0

        trend_strength = (recent_values.iloc[-1] - recent_values.iloc[0]) / recent_values.iloc[0] * 100

        if abs(trend_strength) < 2:
            return 'stable', trend_strength
        elif trend_strength > 5:
            return 'strong_rising', trend_strength
        elif trend_strength > 0:
            return 'rising', trend_strength
        elif trend_strength < -5:
            return 'strong_falling', trend_strength
        else:
            return 'falling', trend_strength

    def apply_emotion_impact(base_score, impact_type, weight_config):
        """应用情绪影响，确保得分在合理范围"""
        if impact_type == 'positive':
            return base_score + weight_config['positive']
        elif impact_type == 'negative':
            return base_score - weight_config['negative']
        return base_score

    # 1. RSI情绪分析（使用前复权数据） - 优化版
    rsi_values = {
        'rsi_6': latest.get('rsi_qfq_6', 50),
        'rsi_12': latest.get('rsi_qfq_12', 50),
        'rsi_24': latest.get('rsi_qfq_24', 50)
    }

    # RSI数据可用性检查
    valid_rsi = [v for v in rsi_values.values() if pd.notna(v) and v != 0]
    if valid_rsi:
        rsi_avg = sum(valid_rsi) / len(valid_rsi)

        # RSI趋势分析
        if 'rsi_qfq_12' in df.columns:
            rsi_trend, rsi_trend_strength = analyze_indicator_trend(df['rsi_qfq_12'], 'RSI', 5)
            trend_analysis['RSI'] = {'trend': rsi_trend, 'strength': rsi_trend_strength}

        # RSI情绪判断 - 使用优化阈值
        if rsi_avg > INDICATOR_THRESHOLDS['RSI']['extreme_high']:
            rsi_emotion = "极度贪婪"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['RSI'])
            emotion_warnings.append(f"RSI显示极度贪婪({rsi_avg:.1f})，市场可能过热")
        elif rsi_avg > INDICATOR_THRESHOLDS['RSI']['high']:
            rsi_emotion = "贪婪"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', {'positive': 6, 'negative': 6})
            emotion_warnings.append(f"RSI显示贪婪情绪({rsi_avg:.1f})，注意风险")
        elif rsi_avg < INDICATOR_THRESHOLDS['RSI']['extreme_low']:
            rsi_emotion = "极度恐慌"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['RSI'])
            emotion_opportunities.append(f"RSI显示极度恐慌({rsi_avg:.1f})，可能存在超跌机会")
        elif rsi_avg < INDICATOR_THRESHOLDS['RSI']['low']:
            rsi_emotion = "恐慌"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', {'positive': 6, 'negative': 6})
            emotion_opportunities.append(f"RSI显示恐慌情绪({rsi_avg:.1f})，关注反弹机会")
        else:
            rsi_emotion = "平衡"
            emotion_signals.append(f"RSI处于平衡区间({rsi_avg:.1f})，情绪相对稳定")
    else:
        rsi_emotion = "数据缺失"

    # 2. CCI情绪分析（顺势指标） - 优化版
    cci = latest.get('cci_qfq', 0)
    cci_available, cci_error = check_data_availability('CCI', cci)

    if cci_available:
        # CCI趋势分析
        if 'cci_qfq' in df.columns:
            cci_trend, cci_trend_strength = analyze_indicator_trend(df['cci_qfq'], 'CCI', 5)
            trend_analysis['CCI'] = {'trend': cci_trend, 'strength': cci_trend_strength}

        if cci > INDICATOR_THRESHOLDS['CCI']['extreme_high']:
            cci_emotion = "强烈看多"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['CCI'])
            emotion_signals.append(f"CCI显示强烈看多情绪({cci:.1f})")
        elif cci > INDICATOR_THRESHOLDS['CCI']['high']:
            cci_emotion = "偏多"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', {'positive': 3, 'negative': 3})
            emotion_signals.append(f"CCI显示偏多情绪({cci:.1f})")
        elif cci < INDICATOR_THRESHOLDS['CCI']['extreme_low']:
            cci_emotion = "强烈看空"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['CCI'])
            emotion_warnings.append(f"CCI显示强烈看空情绪({cci:.1f})")
        elif cci < INDICATOR_THRESHOLDS['CCI']['low']:
            cci_emotion = "偏空"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', {'positive': 3, 'negative': 3})
            emotion_warnings.append(f"CCI显示偏空情绪({cci:.1f})")
        else:
            cci_emotion = "中性"
            emotion_signals.append(f"CCI显示中性情绪({cci:.1f})")
    else:
        cci_emotion = cci_error

    # 3. KDJ情绪分析 - 优化版
    kdj_k = latest.get('kdj_k_qfq', 50)
    kdj_d = latest.get('kdj_d_qfq', 50)
    kdj_j = latest.get('kdj_qfq', 50)

    kdj_values = [v for v in [kdj_k, kdj_d, kdj_j] if pd.notna(v)]
    if kdj_values:
        kdj_avg = sum(kdj_values) / len(kdj_values)

        # KDJ趋势分析
        if 'kdj_k_qfq' in df.columns:
            kdj_trend, kdj_trend_strength = analyze_indicator_trend(df['kdj_k_qfq'], 'KDJ', 3)
            trend_analysis['KDJ'] = {'trend': kdj_trend, 'strength': kdj_trend_strength}

        if kdj_avg > INDICATOR_THRESHOLDS['KDJ']['high']:
            kdj_emotion = "超买"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['KDJ'])
            emotion_warnings.append(f"KDJ显示超买状态({kdj_avg:.1f})，注意回调风险")
        elif kdj_avg < INDICATOR_THRESHOLDS['KDJ']['low']:
            kdj_emotion = "超卖"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['KDJ'])
            emotion_opportunities.append(f"KDJ显示超卖状态({kdj_avg:.1f})，关注反弹机会")
        else:
            kdj_emotion = "正常"
            emotion_signals.append(f"KDJ处于正常区间({kdj_avg:.1f})")
    else:
        kdj_emotion = "数据缺失"

    # 4. MACD情绪分析 - 优化版
    macd_dif = latest.get('macd_dif_qfq', 0)
    macd_dea = latest.get('macd_dea_qfq', 0)
    macd_hist = latest.get('macd_qfq', 0)

    if all(pd.notna([macd_dif, macd_dea, macd_hist])):
        # MACD趋势分析
        if 'macd_qfq' in df.columns:
            macd_trend, macd_trend_strength = analyze_indicator_trend(df['macd_qfq'], 'MACD', 5)
            trend_analysis['MACD'] = {'trend': macd_trend, 'strength': macd_trend_strength}

        # 结合金叉死叉和柱状图分析
        if macd_dif > macd_dea and macd_hist > 0:
            macd_emotion = "积极"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['MACD'])
            emotion_signals.append(f"MACD显示积极情绪，趋势向好")
        elif macd_dif < macd_dea and macd_hist < 0:
            macd_emotion = "消极"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['MACD'])
            emotion_warnings.append(f"MACD显示消极情绪，趋势偏弱")
        else:
            macd_emotion = "转换中"
            emotion_signals.append(f"MACD显示情绪转换中")
    else:
        macd_emotion = "数据缺失"

    # 5. PSY心理线分析 - 优化版
    psy = latest.get('psy_qfq', 50)
    psy_available, psy_error = check_data_availability('PSY', psy)

    if psy_available:
        if psy > INDICATOR_THRESHOLDS['PSY']['extreme_high']:
            psy_emotion = "极度乐观"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['PSY'])
            emotion_warnings.append(f"PSY显示极度乐观({psy:.1f})，市场可能过热")
        elif psy > INDICATOR_THRESHOLDS['PSY']['high']:
            psy_emotion = "偏乐观"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', {'positive': 2, 'negative': 2})
            emotion_warnings.append(f"PSY显示偏乐观({psy:.1f})，注意风险")
        elif psy < INDICATOR_THRESHOLDS['PSY']['extreme_low']:
            psy_emotion = "极度悲观"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['PSY'])
            emotion_opportunities.append(f"PSY显示极度悲观({psy:.1f})，可能存在机会")
        elif psy < INDICATOR_THRESHOLDS['PSY']['low']:
            psy_emotion = "偏悲观"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', {'positive': 2, 'negative': 2})
            emotion_opportunities.append(f"PSY显示偏悲观({psy:.1f})，关注反弹")
        else:
            psy_emotion = "理性"
            emotion_signals.append(f"PSY显示理性情绪({psy:.1f})")
    else:
        psy_emotion = psy_error

    # 6. VR成交量比率分析 - 优化版
    vr = latest.get('vr_qfq', 100)
    vr_available, vr_error = check_data_availability('VR', vr)

    if vr_available:
        if vr > INDICATOR_THRESHOLDS['VR']['extreme_high']:
            vr_emotion = "过度活跃"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['VR'])
            emotion_warnings.append(f"VR显示成交过度活跃({vr:.1f})，注意风险")
        elif vr > INDICATOR_THRESHOLDS['VR']['high']:
            vr_emotion = "较活跃"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', {'positive': 1, 'negative': 1})
            emotion_signals.append(f"VR显示成交较活跃({vr:.1f})")
        elif vr < INDICATOR_THRESHOLDS['VR']['extreme_low']:
            vr_emotion = "过度低迷"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['VR'])
            emotion_opportunities.append(f"VR显示成交低迷({vr:.1f})，可能酝酿机会")
        elif vr < INDICATOR_THRESHOLDS['VR']['low']:
            vr_emotion = "偏低迷"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', {'positive': 1, 'negative': 1})
            emotion_opportunities.append(f"VR显示成交偏低迷({vr:.1f})")
        else:
            vr_emotion = "正常"
            emotion_signals.append(f"VR显示成交量正常({vr:.1f})")
    else:
        vr_emotion = vr_error

    # 7. OBV能量潮分析 - 优化版
    if len(df) >= 2:
        obv_current = latest.get('obv_qfq', 0)
        obv_previous = df.iloc[-2].get('obv_qfq', 0)

        if pd.notna(obv_current) and pd.notna(obv_previous) and obv_previous != 0:
            obv_change = (obv_current - obv_previous) / abs(obv_previous) * 100

            # OBV趋势分析
            if 'obv_qfq' in df.columns:
                obv_trend, obv_trend_strength = analyze_indicator_trend(df['obv_qfq'], 'OBV', 5)
                trend_analysis['OBV'] = {'trend': obv_trend, 'strength': obv_trend_strength}

            if obv_change > 15:
                obv_emotion = "资金大幅流入"
                emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['OBV'])
                emotion_signals.append(f"OBV显示资金大幅流入({obv_change:.1f}%)")
            elif obv_change > 5:
                obv_emotion = "资金流入积极"
                emotion_score = apply_emotion_impact(emotion_score, 'positive', {'positive': 3, 'negative': 3})
                emotion_signals.append(f"OBV显示资金流入积极({obv_change:.1f}%)")
            elif obv_change < -15:
                obv_emotion = "资金大幅流出"
                emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['OBV'])
                emotion_warnings.append(f"OBV显示资金大幅流出({obv_change:.1f}%)")
            elif obv_change < -5:
                obv_emotion = "资金流出明显"
                emotion_score = apply_emotion_impact(emotion_score, 'negative', {'positive': 3, 'negative': 3})
                emotion_warnings.append(f"OBV显示资金流出明显({obv_change:.1f}%)")
            else:
                obv_emotion = "资金流动平稳"
                emotion_signals.append(f"OBV显示资金流动平稳({obv_change:.1f}%)")
        else:
            obv_emotion = "数据缺失"
    else:
        obv_emotion = "数据不足"

    # 8. MFI资金流量指标分析 - 优化版
    mfi = latest.get('mfi_qfq', 50)
    mfi_available, mfi_error = check_data_availability('MFI', mfi)

    if mfi_available:
        if mfi > INDICATOR_THRESHOLDS['MFI']['high']:
            mfi_emotion = "资金过度流入"
            emotion_score = apply_emotion_impact(emotion_score, 'negative', EMOTION_WEIGHTS['MFI'])
            emotion_warnings.append(f"MFI显示资金过度流入({mfi:.1f})，注意回调")
        elif mfi < INDICATOR_THRESHOLDS['MFI']['low']:
            mfi_emotion = "资金严重流出"
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['MFI'])
            emotion_opportunities.append(f"MFI显示资金严重流出({mfi:.1f})，关注底部")
        else:
            mfi_emotion = "资金流动正常"
            emotion_signals.append(f"MFI显示资金流动正常({mfi:.1f})")
    else:
        mfi_emotion = mfi_error

    # 9. 成交量确认分析 - 新增
    if 'vol' in df.columns and len(df) >= 10:
        recent_vol = recent_10['vol'].mean()
        overall_vol = df['vol'].mean()
        volume_ratio = recent_vol / overall_vol if overall_vol > 0 else 1

        if volume_ratio > 2.0:
            emotion_score = apply_emotion_impact(emotion_score, 'positive', EMOTION_WEIGHTS['VOLUME'])
            emotion_signals.append(f"成交量大幅放大({volume_ratio:.1f}倍)，情绪确认有效")
        elif volume_ratio > 1.5:
            emotion_score = apply_emotion_impact(emotion_score, 'positive', {'positive': 2, 'negative': 2})
            emotion_signals.append(f"成交量明显放大({volume_ratio:.1f}倍)，情绪有所确认")
        elif volume_ratio < 0.7:
            emotion_score = apply_emotion_impact(emotion_score, 'negative', {'positive': 1, 'negative': 1})
            emotion_warnings.append(f"成交量萎缩({volume_ratio:.1f}倍)，情绪信号偏弱")

    # 应用得分范围限制 - 关键优化
    emotion_score = max(5, min(95, emotion_score))  # 严格限制在5-95范围

    # 综合情绪等级评定 - 优化后阈值
    if emotion_score >= 80:
        emotion_level = "极度乐观"
    elif emotion_score >= 68:
        emotion_level = "乐观"
    elif emotion_score >= 58:
        emotion_level = "偏乐观"
    elif emotion_score >= 42:
        emotion_level = "中性"
    elif emotion_score >= 32:
        emotion_level = "偏悲观"
    elif emotion_score >= 20:
        emotion_level = "悲观"
    else:
        emotion_level = "极度悲观"

    # 计算数据完整性
    total_indicators = 8
    available_indicators = sum([
        1 if valid_rsi else 0,
        1 if cci_available else 0,
        1 if kdj_values else 0,
        1 if all(pd.notna([macd_dif, macd_dea, macd_hist])) else 0,
        1 if psy_available else 0,
        1 if vr_available else 0,
        1 if obv_emotion != "数据缺失" and obv_emotion != "数据不足" else 0,
        1 if mfi_available else 0
    ])
    data_completeness = available_indicators / total_indicators * 100

    # 生成专业情绪分析报告 - 增强版
    emotion_analysis = generate_enhanced_emotion_analysis_report(
        emotion_level, emotion_score, data_completeness, trend_analysis,
        rsi_emotion, cci_emotion, kdj_emotion, macd_emotion,
        psy_emotion, vr_emotion, obv_emotion, mfi_emotion,
        emotion_signals, emotion_warnings, emotion_opportunities
    )

    return {
        'emotion_score': emotion_score,
        'emotion_level': emotion_level,
        'rsi_emotion': rsi_emotion,
        'cci_emotion': cci_emotion,
        'kdj_emotion': kdj_emotion,
        'macd_emotion': macd_emotion,
        'psy_emotion': psy_emotion,
        'vr_emotion': vr_emotion,
        'obv_emotion': obv_emotion,
        'mfi_emotion': mfi_emotion,
        'emotion_analysis': emotion_analysis,
        'emotion_signals': emotion_signals,
        'emotion_warnings': emotion_warnings,
        'emotion_opportunities': emotion_opportunities,
        'data_completeness': data_completeness,
        'trend_analysis': trend_analysis
    }


def generate_enhanced_emotion_analysis_report(emotion_level, emotion_score, data_completeness, trend_analysis,
                                              rsi_emotion, cci_emotion, kdj_emotion, macd_emotion,
                                              psy_emotion, vr_emotion, obv_emotion, mfi_emotion,
                                              signals, warnings, opportunities):
    """生成增强版专业情绪分析报告"""

    report = f"综合情绪评级：{emotion_level}（{emotion_score}分/100分）\n"
    report += f"数据完整性：{data_completeness:.1f}% | 权重优化：已应用 | 趋势分析：已整合\n\n"

    report += "📊 情绪指标详细分析：\n"
    report += f"• RSI情绪状态：{rsi_emotion}（反映市场超买超卖情绪）\n"
    report += f"• CCI顺势情绪：{cci_emotion}（反映趋势跟随情绪）\n"
    report += f"• KDJ随机情绪：{kdj_emotion}（反映短期情绪波动）\n"
    report += f"• MACD趋势情绪：{macd_emotion}（反映中期趋势情绪）\n"
    report += f"• PSY心理情绪：{psy_emotion}（反映投资者心理状态）\n"
    report += f"• VR成交情绪：{vr_emotion}（反映成交活跃度情绪）\n"
    report += f"• OBV资金情绪：{obv_emotion}（反映资金流向情绪）\n"
    report += f"• MFI资金流情绪：{mfi_emotion}（反映资金流量情绪）\n\n"

    # 趋势分析报告
    if trend_analysis:
        report += "📈 技术指标趋势分析：\n"
        for indicator, trend_info in trend_analysis.items():
            trend_desc = {
                'strong_rising': '强劲上升',
                'rising': '温和上升',
                'stable': '横盘整理',
                'falling': '温和下降',
                'strong_falling': '快速下降',
                'insufficient_data': '数据不足',
                'data_missing': '数据缺失'
            }.get(trend_info['trend'], trend_info['trend'])

            if trend_info['trend'] not in ['insufficient_data', 'data_missing']:
                report += f"• {indicator}趋势：{trend_desc}（{trend_info['strength']:+.1f}%）\n"
            else:
                report += f"• {indicator}趋势：{trend_desc}\n"
        report += "\n"

    if signals:
        report += "✅ 积极信号：\n"
        for signal in signals:
            report += f"• {signal}\n"
        report += "\n"

    if warnings:
        report += "⚠️ 风险警示：\n"
        for warning in warnings:
            report += f"• {warning}\n"
        report += "\n"

    if opportunities:
        report += "🎯 机会提示：\n"
        for opportunity in opportunities:
            report += f"• {opportunity}\n"
        report += "\n"

    # 优化后的情绪建议
    if emotion_score >= 75:
        report += "💡 情绪建议：市场情绪过于乐观，建议获利了结，严格控制仓位。\n"
    elif emotion_score >= 60:
        report += "💡 情绪建议：市场情绪偏向乐观，可适度参与，注意风险控制。\n"
    elif emotion_score >= 45:
        report += "💡 情绪建议：市场情绪相对平衡，保持谨慎观望，等待明确信号。\n"
    elif emotion_score >= 30:
        report += "💡 情绪建议：市场情绪偏向悲观，可关注优质标的，分批建仓。\n"
    else:
        report += "💡 情绪建议：市场情绪过度悲观，可能存在超跌机会，但需谨慎操作。\n"

    # 数据质量提示
    if data_completeness < 70:
        report += f"\n⚠️ 数据质量提示：当前数据完整性{data_completeness:.1f}%，分析结果可信度有限。\n"
    elif data_completeness < 90:
        report += f"\n📊 数据质量提示：数据完整性{data_completeness:.1f}%，分析结果基本可信。\n"
    else:
        report += f"\n✅ 数据质量提示：数据完整性{data_completeness:.1f}%，分析结果高度可信。\n"

    return report


def get_enhanced_stock_data_with_emotion(stock_code, start_date, end_date):
    """
    获取增强版股票数据（包含情绪指标）- 使用前复权数据
    """
    try:
        with api_lock:
            hist_data = pro.stk_factor_pro(**{
                "ts_code": stock_code,
                "start_date": start_date,
                "end_date": end_date,
                "trade_date": "",
                "limit": "",
                "offset": ""
            }, fields=[
                # 基础数据
                "ts_code", "trade_date", "open", "open_qfq", "high", "high_qfq",
                "low", "low_qfq", "close", "close_qfq", "pre_close", "change",
                "pct_chg", "vol", "amount", "turnover_rate", "total_mv",
                # 情绪相关指标（前复权）
                "rsi_qfq_6", "rsi_qfq_12", "rsi_qfq_24",
                "cci_qfq", "kdj_k_qfq", "kdj_d_qfq", "kdj_qfq",
                "macd_dif_qfq", "macd_dea_qfq", "macd_qfq",
                "psy_qfq", "vr_qfq", "obv_qfq", "mfi_qfq",
                # 其他技术指标
                "ma_qfq_5", "ma_qfq_10", "ma_qfq_20", "ma_qfq_60"
            ])

        if len(hist_data) == 0:
            # 备用方案：使用原接口
            with api_lock:
                hist_data = pro.daily(ts_code=stock_code, start_date=start_date, end_date=end_date)
            # 简化处理，添加前复权字段
            for col in ['open', 'high', 'low', 'close']:
                hist_data[f'{col}_qfq'] = hist_data[col]

        return hist_data

    except Exception as e:
        print(f"获取情绪数据失败 {stock_code}: {e}")
        # 返回基础数据
        try:
            with api_lock:
                hist_data = pro.daily(ts_code=stock_code, start_date=start_date, end_date=end_date)
            for col in ['open', 'high', 'low', 'close']:
                hist_data[f'{col}_qfq'] = hist_data[col]
            return hist_data
        except:
            return pd.DataFrame()
        # 情绪分析部分结束


def calculate_atr(hist_data, period=14):
    """计算ATR（平均真实波幅）用于动态止损 - 使用前复权数据"""
    df = hist_data.copy().sort_values('trade_date')

    # 使用前复权数据计算ATR
    df['prev_close'] = df['close_qfq'].shift(1)
    df['tr1'] = df['high_qfq'] - df['low_qfq']
    df['tr2'] = abs(df['high_qfq'] - df['prev_close'])
    df['tr3'] = abs(df['low_qfq'] - df['prev_close'])
    df['tr'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)

    # 计算ATR
    df['atr'] = df['tr'].rolling(window=period).mean()

    return df.iloc[-1]['atr'] if pd.notna(df.iloc[-1]['atr']) else df.iloc[-1]['close_qfq'] * 0.02


def calculate_market_strength(hist_data):
    """计算市场强度指标 - 使用前复权数据"""
    df = hist_data.copy().sort_values('trade_date')
    recent = df.tail(20)

    # 计算上涨天数比例
    up_days = len(recent[recent['pct_chg'] > 0])
    strength_ratio = up_days / len(recent)

    # 计算平均涨跌幅
    avg_change = recent['pct_chg'].mean()

    # 计算波动率
    volatility = recent['pct_chg'].std()

    return {
        'strength_ratio': strength_ratio,
        'avg_change': avg_change,
        'volatility': volatility
    }


def calculate_four_dimensional_analysis(hist_data):
    """
    专业四维结构分析法 - 使用前复权数据
    四个维度：时间、价格、成交量、空间
    """
    df = hist_data.copy().sort_values('trade_date')

    if len(df) < 60:
        return {
            'time_dimension': {'trend': '数据不足', 'cycle_analysis': '无法分析'},
            'price_dimension': {'structure': '数据不足', 'key_levels': []},
            'volume_dimension': {'distribution': '数据不足', 'anomaly': '无法检测'},
            'space_dimension': {'volatility': '数据不足', 'range_analysis': '无法分析'},
            'comprehensive_score': 0,
            'structure_type': '无法确定',
            'structure_strength': '弱'
        }

    # 第一维度：时间维度分析
    time_analysis = analyze_time_dimension(df)

    # 第二维度：价格维度分析
    price_analysis = analyze_price_dimension(df)

    # 第三维度：成交量维度分析
    volume_analysis = analyze_volume_dimension(df)

    # 第四维度：空间维度分析
    space_analysis = analyze_space_dimension(df)

    # 综合评分计算
    comprehensive_score = calculate_comprehensive_score(
        time_analysis, price_analysis, volume_analysis, space_analysis
    )

    # 结构类型判断
    structure_type = determine_structure_type(
        time_analysis, price_analysis, volume_analysis, space_analysis
    )

    return {
        'time_dimension': time_analysis,
        'price_dimension': price_analysis,
        'volume_dimension': volume_analysis,
        'space_dimension': space_analysis,
        'comprehensive_score': comprehensive_score,
        'structure_type': structure_type,
        'structure_strength': get_structure_strength(comprehensive_score)
    }


def analyze_time_dimension(df):
    """时间维度分析：趋势持续性、周期性 - 使用前复权数据"""
    recent_60 = df.tail(60)
    recent_20 = df.tail(20)
    recent_5 = df.tail(5)

    # 多周期趋势分析 - 使用前复权收盘价
    trend_5d = "上升" if recent_5['close_qfq'].iloc[-1] > recent_5['close_qfq'].iloc[0] else "下降"
    trend_20d = "上升" if recent_20['close_qfq'].iloc[-1] > recent_20['close_qfq'].iloc[0] else "下降"
    trend_60d = "上升" if recent_60['close_qfq'].iloc[-1] > recent_60['close_qfq'].iloc[0] else "下降"

    # 趋势一致性分析
    trend_consistency = 0
    if trend_5d == trend_20d == trend_60d:
        trend_consistency = 90  # 高度一致
    elif (trend_5d == trend_20d) or (trend_20d == trend_60d):
        trend_consistency = 60  # 中等一致
    else:
        trend_consistency = 30  # 低一致性

    # 价格动能分析 - 使用前复权数据
    momentum_5d = (recent_5['close_qfq'].iloc[-1] / recent_5['close_qfq'].iloc[0] - 1) * 100
    momentum_20d = (recent_20['close_qfq'].iloc[-1] / recent_20['close_qfq'].iloc[0] - 1) * 100

    # 周期性分析（基于波峰波谷）- 使用前复权数据
    highs = df['high_qfq'].values
    lows = df['low_qfq'].values

    # 寻找局部极值
    high_peaks = argrelextrema(highs, np.greater, order=5)[0] if len(highs) > 10 else []
    low_valleys = argrelextrema(lows, np.less, order=5)[0] if len(lows) > 10 else []

    # 计算平均周期
    if len(high_peaks) > 2:
        avg_peak_cycle = np.mean(np.diff(high_peaks))
    else:
        avg_peak_cycle = 0

    if len(low_valleys) > 2:
        avg_valley_cycle = np.mean(np.diff(low_valleys))
    else:
        avg_valley_cycle = 0

    # 当前位置判断
    current_position = "中性"
    if len(high_peaks) > 0 and len(low_valleys) > 0:
        last_high_idx = high_peaks[-1] if len(high_peaks) > 0 else 0
        last_low_idx = low_valleys[-1] if len(low_valleys) > 0 else 0
        current_idx = len(df) - 1

        if last_high_idx > last_low_idx:
            days_from_high = current_idx - last_high_idx
            if days_from_high < 5:
                current_position = "高位附近"
            elif days_from_high < 15:
                current_position = "高位回落"
            else:
                current_position = "下降通道"
        else:
            days_from_low = current_idx - last_low_idx
            if days_from_low < 5:
                current_position = "低位附近"
            elif days_from_low < 15:
                current_position = "低位反弹"
            else:
                current_position = "上升通道"

    return {
        'short_trend': trend_5d,
        'medium_trend': trend_20d,
        'long_trend': trend_60d,
        'trend_consistency': trend_consistency,
        'momentum_5d': momentum_5d,
        'momentum_20d': momentum_20d,
        'avg_cycle': (avg_peak_cycle + avg_valley_cycle) / 2 if avg_peak_cycle > 0 and avg_valley_cycle > 0 else 0,
        'current_position': current_position,
        'time_score': min(trend_consistency + abs(momentum_20d) * 2, 100)
    }


def analyze_price_dimension(df):
    """价格维度分析：结构形态、关键价位 - 使用前复权数据"""
    recent_data = df.tail(60)

    # 价格结构分析 - 使用前复权数据
    current_price = recent_data['close_qfq'].iloc[-1]
    period_high = recent_data['high_qfq'].max()
    period_low = recent_data['low_qfq'].min()

    # 价格位置
    price_position = (current_price - period_low) / (period_high - period_low) * 100

    # 关键价位识别
    key_levels = []

    # 支撑阻力位（基于密集成交区域）
    price_ranges = np.linspace(period_low, period_high, 20)
    volume_at_price = []

    for i in range(len(price_ranges) - 1):
        range_low = price_ranges[i]
        range_high = price_ranges[i + 1]
        volume_in_range = recent_data[
            (recent_data['low_qfq'] <= range_high) & (recent_data['high_qfq'] >= range_low)
            ]['vol'].sum()
        volume_at_price.append((range_low + range_high) / 2)

    # 找出成交量最大的价位区间作为关键位
    if len(volume_at_price) > 0:
        sorted_indices = np.argsort(volume_at_price)[-3:]  # 取前3个
        key_levels = [price_ranges[i] for i in sorted_indices]

    # 斐波那契回调位
    fib_levels = []
    if period_high != period_low:
        fib_ratios = [0.236, 0.382, 0.5, 0.618, 0.786]
        for ratio in fib_ratios:
            fib_level = period_high - (period_high - period_low) * ratio
            fib_levels.append(fib_level)

    # 价格形态识别
    price_pattern = identify_price_pattern(recent_data)

    # 波动率分析 - 使用前复权数据
    returns = recent_data['close_qfq'].pct_change().dropna()
    volatility = returns.std() * np.sqrt(252) * 100  # 年化波动率

    return {
        'current_position_pct': price_position,
        'key_support_levels': key_levels[:2] if len(key_levels) >= 2 else key_levels,
        'key_resistance_levels': key_levels[2:] if len(key_levels) > 2 else [],
        'fibonacci_levels': fib_levels,
        'price_pattern': price_pattern,
        'volatility': volatility,
        'price_score': min(abs(price_position - 50) + (100 - volatility), 100)
    }


def analyze_volume_dimension(df):
    """成交量维度分析：量价关系、异常量能"""
    recent_data = df.tail(60)

    if 'vol' not in recent_data.columns:
        return {
            'volume_trend': '数据缺失',
            'price_volume_correlation': 0,
            'volume_anomaly': '无法检测',
            'volume_distribution': '数据缺失',
            'volume_score': 0
        }

    # 成交量趋势分析
    volume_ma5 = recent_data['vol'].rolling(5).mean()
    volume_ma20 = recent_data['vol'].rolling(20).mean()

    current_vol_ratio = recent_data['vol'].iloc[-1] / volume_ma20.iloc[-1]

    volume_trend = "正常"
    if current_vol_ratio > 3:
        volume_trend = "爆量"
    elif current_vol_ratio > 2:
        volume_trend = "巨量"
    elif current_vol_ratio > 1.5:
        volume_trend = "放量"
    elif current_vol_ratio < 0.5:
        volume_trend = "缩量"

    # 量价相关性分析 - 使用前复权数据
    price_changes = recent_data['close_qfq'].pct_change().dropna()
    volume_changes = recent_data['vol'].pct_change().dropna()

    if len(price_changes) > 5 and len(volume_changes) > 5:
        min_len = min(len(price_changes), len(volume_changes))
        correlation = np.corrcoef(
            price_changes.iloc[-min_len:],
            volume_changes.iloc[-min_len:]
        )[0, 1]
        correlation = correlation if not np.isnan(correlation) else 0
    else:
        correlation = 0

    # 异常量能检测
    volume_std = recent_data['vol'].std()
    volume_mean = recent_data['vol'].mean()
    recent_volume = recent_data['vol'].iloc[-1]

    z_score = (recent_volume - volume_mean) / volume_std if volume_std > 0 else 0

    volume_anomaly = "正常"
    if abs(z_score) > 3:
        volume_anomaly = "极异常" if z_score > 0 else "极缩量"
    elif abs(z_score) > 2:
        volume_anomaly = "异常" if z_score > 0 else "明显缩量"
    elif abs(z_score) > 1:
        volume_anomaly = "偏高" if z_score > 0 else "偏低"

    # 成交量分布分析
    volume_quartiles = recent_data['vol'].quantile([0.25, 0.5, 0.75])
    current_vol_position = "低量区"
    if recent_volume > volume_quartiles[0.75]:
        current_vol_position = "高量区"
    elif recent_volume > volume_quartiles[0.5]:
        current_vol_position = "中高量区"
    elif recent_volume > volume_quartiles[0.25]:
        current_vol_position = "中低量区"

    return {
        'volume_trend': volume_trend,
        'price_volume_correlation': correlation,
        'volume_anomaly': volume_anomaly,
        'volume_distribution': current_vol_position,
        'volume_ratio': current_vol_ratio,
        'volume_score': min(abs(correlation) * 50 + min(current_vol_ratio, 3) * 20, 100)
    }


def analyze_space_dimension(df):
    """空间维度分析：波动空间、支撑阻力强度 - 使用前复权数据"""
    recent_data = df.tail(60)

    # 波动空间分析 - 使用前复权数据
    current_price = recent_data['close_qfq'].iloc[-1]
    period_high = recent_data['high_qfq'].max()
    period_low = recent_data['low_qfq'].min()

    total_range = period_high - period_low
    current_position = (current_price - period_low) / total_range * 100

    # 日内波动分析 - 使用前复权数据
    daily_ranges = (recent_data['high_qfq'] - recent_data['low_qfq']) / recent_data['close_qfq'] * 100
    avg_daily_range = daily_ranges.mean()
    current_daily_range = daily_ranges.iloc[-1]

    # 支撑阻力强度分析
    # 计算价格在各个水平的停留时间和反弹次数
    support_strength = calculate_level_strength(recent_data, period_low, is_support=True)
    resistance_strength = calculate_level_strength(recent_data, period_high, is_support=False)

    # 空间利用率
    space_utilization = 100 - abs(current_position - 50)  # 越接近中间，利用率越低

    # 突破概率评估
    breakthrough_probability = 50  # 基础概率

    if current_position > 80:  # 高位
        breakthrough_probability = 30 + resistance_strength * 20
    elif current_position < 20:  # 低位
        breakthrough_probability = 30 + support_strength * 20
    else:  # 中位
        breakthrough_probability = 50

    return {
        'current_position_pct': current_position,
        'total_range_pct': total_range / current_price * 100,
        'avg_daily_range': avg_daily_range,
        'current_daily_range': current_daily_range,
        'support_strength': support_strength,
        'resistance_strength': resistance_strength,
        'space_utilization': space_utilization,
        'breakthrough_probability': breakthrough_probability,
        'space_score': min(space_utilization + avg_daily_range * 2, 100)
    }


def calculate_level_strength(df, level, is_support=True, tolerance=0.02):
    """计算支撑或阻力位的强度 - 使用前复权数据"""
    touches = 0
    bounces = 0

    level_range_low = level * (1 - tolerance)
    level_range_high = level * (1 + tolerance)

    for i in range(1, len(df)):
        if is_support:
            # 检查是否触及支撑位 - 使用前复权数据
            if df.iloc[i]['low_qfq'] <= level_range_high and df.iloc[i]['low_qfq'] >= level_range_low:
                touches += 1
                # 检查是否反弹
                if i < len(df) - 1 and df.iloc[i + 1]['close_qfq'] > df.iloc[i]['close_qfq']:
                    bounces += 1
        else:
            # 检查是否触及阻力位 - 使用前复权数据
            if df.iloc[i]['high_qfq'] <= level_range_high and df.iloc[i]['high_qfq'] >= level_range_low:
                touches += 1
                # 检查是否回落
                if i < len(df) - 1 and df.iloc[i + 1]['close_qfq'] < df.iloc[i]['close_qfq']:
                    bounces += 1

    strength = bounces / touches if touches > 0 else 0
    return min(strength, 1.0)


def identify_price_pattern(df):
    """识别价格形态 - 使用前复权数据"""
    if len(df) < 20:
        return "数据不足"

    recent_20 = df.tail(20)
    highs = recent_20['high_qfq'].values
    lows = recent_20['low_qfq'].values
    closes = recent_20['close_qfq'].values

    # 寻找局部极值
    high_peaks_idx = argrelextrema(highs, np.greater, order=3)[0]
    low_valleys_idx = argrelextrema(lows, np.less, order=3)[0]

    pattern = "震荡整理"

    # 双顶形态检测
    if len(high_peaks_idx) >= 2:
        last_two_peaks = high_peaks_idx[-2:]
        peak_heights = highs[last_two_peaks]
        if abs(peak_heights[1] / peak_heights[0] - 1) < 0.03:  # 高度相近
            pattern = "双顶形态"

    # 双底形态检测
    if len(low_valleys_idx) >= 2:
        last_two_valleys = low_valleys_idx[-2:]
        valley_depths = lows[last_two_valleys]
        if abs(valley_depths[1] / valley_depths[0] - 1) < 0.03:  # 深度相近
            pattern = "双底形态"

    # 头肩形态检测（简化版）
    if len(high_peaks_idx) >= 3:
        last_three_peaks = high_peaks_idx[-3:]
        peak_heights = highs[last_three_peaks]
        if (peak_heights[1] > peak_heights[0] and
                peak_heights[1] > peak_heights[2] and
                abs(peak_heights[0] / peak_heights[2] - 1) < 0.05):
            pattern = "头肩顶形态"

    if len(low_valleys_idx) >= 3:
        last_three_valleys = low_valleys_idx[-3:]
        valley_depths = lows[last_three_valleys]
        if (valley_depths[1] < valley_depths[0] and
                valley_depths[1] < valley_depths[2] and
                abs(valley_depths[0] / valley_depths[2] - 1) < 0.05):
            pattern = "头肩底形态"

    # 趋势形态检测
    first_close = closes[0]
    last_close = closes[-1]
    trend_strength = (last_close / first_close - 1) * 100

    if trend_strength > 5:
        pattern = f"上升趋势 (+{trend_strength:.1f}%)"
    elif trend_strength < -5:
        pattern = f"下降趋势 ({trend_strength:.1f}%)"

    return pattern


def calculate_comprehensive_score(time_analysis, price_analysis, volume_analysis, space_analysis):
    """计算四维分析综合得分"""
    time_score = time_analysis.get('time_score', 0)
    price_score = price_analysis.get('price_score', 0)
    volume_score = volume_analysis.get('volume_score', 0)
    space_score = space_analysis.get('space_score', 0)

    # 权重分配：时间30%，价格30%，成交量25%，空间15%
    comprehensive_score = (
            time_score * 0.30 +
            price_score * 0.30 +
            volume_score * 0.25 +
            space_score * 0.15
    )

    return min(comprehensive_score, 100)


def determine_structure_type(time_analysis, price_analysis, volume_analysis, space_analysis):
    """确定结构类型"""
    trend_consistency = time_analysis.get('trend_consistency', 0)
    price_position = price_analysis.get('current_position_pct', 50)
    volume_trend = volume_analysis.get('volume_trend', '正常')
    space_position = space_analysis.get('current_position_pct', 50)

    if trend_consistency > 70:
        if price_position > 70 and volume_trend in ['放量', '巨量', '爆量']:
            return "强势突破结构"
        elif price_position < 30 and volume_trend in ['放量', '巨量', '爆量']:
            return "强势反转结构"
        elif trend_consistency > 85:
            return "趋势延续结构"
        else:
            return "健康调整结构"
    elif 40 < price_position < 60:
        return "平衡震荡结构"
    elif price_position > 80 or price_position < 20:
        return "极值反转结构"
    else:
        return "不明确结构"


def get_structure_strength(score):
    """根据综合得分评估结构强度"""
    if score >= 80:
        return "极强"
    elif score >= 65:
        return "强"
    elif score >= 50:
        return "中等"
    elif score >= 35:
        return "偏弱"
    else:
        return "弱"


def analyze_top_bottom_structure(hist_data):
    """
    专业顶部底部结构分析 - 使用前复权数据
    识别各种顶底形态并评估其有效性
    """
    df = hist_data.copy().sort_values('trade_date')

    if len(df) < 30:
        return {
            'top_structures': [],
            'bottom_structures': [],
            'current_structure': '数据不足',
            'structure_reliability': 0,
            'breakout_probability': 50,
            'key_levels': [],
            'structure_analysis': '历史数据不足，无法进行有效的顶底结构分析'
        }

    # 分析不同时间跨度的结构
    structures_60d = analyze_structure_period(df.tail(60), "60日")
    structures_30d = analyze_structure_period(df.tail(30), "30日")
    structures_15d = analyze_structure_period(df.tail(15), "15日")

    # 合并所有结构
    all_top_structures = (structures_60d['tops'] + structures_30d['tops'] +
                          structures_15d['tops'])
    all_bottom_structures = (structures_60d['bottoms'] + structures_30d['bottoms'] +
                             structures_15d['bottoms'])

    # 当前结构判断
    current_structure = determine_current_structure(df, all_top_structures, all_bottom_structures)

    # 结构可靠性评估
    reliability = assess_structure_reliability(df, all_top_structures, all_bottom_structures)

    # 突破概率评估
    breakout_prob = assess_breakout_probability(df, current_structure, reliability)

    # 关键价位提取
    key_levels = extract_key_levels(all_top_structures, all_bottom_structures)

    # 生成结构分析报告
    structure_analysis = generate_structure_analysis_report(
        current_structure, all_top_structures, all_bottom_structures, reliability
    )

    return {
        'top_structures': all_top_structures,
        'bottom_structures': all_bottom_structures,
        'current_structure': current_structure,
        'structure_reliability': reliability,
        'breakout_probability': breakout_prob,
        'key_levels': key_levels,
        'structure_analysis': structure_analysis
    }


def analyze_structure_period(df, period_name):
    """分析特定周期的结构形态 - 使用前复权数据"""
    if len(df) < 10:
        return {'tops': [], 'bottoms': []}

    highs = df['high_qfq'].values
    lows = df['low_qfq'].values
    closes = df['close_qfq'].values
    dates = df['trade_date'].values

    # 寻找局部极值点
    high_peaks_idx = argrelextrema(highs, np.greater, order=2)[0]
    low_valleys_idx = argrelextrema(lows, np.less, order=2)[0]

    top_structures = []
    bottom_structures = []

    # 分析顶部结构
    top_structures.extend(detect_double_top(df, high_peaks_idx, period_name))
    top_structures.extend(detect_triple_top(df, high_peaks_idx, period_name))
    top_structures.extend(detect_head_shoulders_top(df, high_peaks_idx, period_name))
    top_structures.extend(detect_rising_wedge(df, period_name))

    # 分析底部结构
    bottom_structures.extend(detect_double_bottom(df, low_valleys_idx, period_name))
    bottom_structures.extend(detect_triple_bottom(df, low_valleys_idx, period_name))
    bottom_structures.extend(detect_head_shoulders_bottom(df, low_valleys_idx, period_name))
    bottom_structures.extend(detect_falling_wedge(df, period_name))

    return {'tops': top_structures, 'bottoms': bottom_structures}


def detect_double_top(df, peaks_idx, period):
    """检测双顶形态 - 使用前复权数据"""
    structures = []

    if len(peaks_idx) < 2:
        return structures

    highs = df['high_qfq'].values

    for i in range(len(peaks_idx) - 1):
        peak1_idx = peaks_idx[i]
        peak2_idx = peaks_idx[i + 1]

        peak1_price = highs[peak1_idx]
        peak2_price = highs[peak2_idx]

        # 双顶条件：两个高点相近（差异小于3%）
        price_diff = abs(peak1_price - peak2_price) / max(peak1_price, peak2_price)

        if price_diff < 0.03:
            # 计算颈线位
            valley_between = df.iloc[peak1_idx:peak2_idx]['low_qfq'].min()

            # 计算强度指标
            strength = calculate_pattern_strength(df, peak1_idx, peak2_idx, 'double_top')

            structure = {
                'type': '双顶',
                'period': period,
                'peak1_price': peak1_price,
                'peak2_price': peak2_price,
                'neckline': valley_between,
                'strength': strength,
                'target_price': valley_between - (max(peak1_price, peak2_price) - valley_between),
                'reliability': 'high' if strength > 70 else 'medium' if strength > 50 else 'low',
                'formation_dates': [df.iloc[peak1_idx]['trade_date'], df.iloc[peak2_idx]['trade_date']]
            }
            structures.append(structure)

    return structures


def detect_double_bottom(df, valleys_idx, period):
    """检测双底形态 - 使用前复权数据"""
    structures = []

    if len(valleys_idx) < 2:
        return structures

    lows = df['low_qfq'].values

    for i in range(len(valleys_idx) - 1):
        valley1_idx = valleys_idx[i]
        valley2_idx = valleys_idx[i + 1]

        valley1_price = lows[valley1_idx]
        valley2_price = lows[valley2_idx]

        # 双底条件：两个低点相近（差异小于3%）
        price_diff = abs(valley1_price - valley2_price) / max(valley1_price, valley2_price)

        if price_diff < 0.03:
            # 计算颈线位
            peak_between = df.iloc[valley1_idx:valley2_idx]['high_qfq'].max()

            # 计算强度指标
            strength = calculate_pattern_strength(df, valley1_idx, valley2_idx, 'double_bottom')

            structure = {
                'type': '双底',
                'period': period,
                'valley1_price': valley1_price,
                'valley2_price': valley2_price,
                'neckline': peak_between,
                'strength': strength,
                'target_price': peak_between + (peak_between - min(valley1_price, valley2_price)),
                'reliability': 'high' if strength > 70 else 'medium' if strength > 50 else 'low',
                'formation_dates': [df.iloc[valley1_idx]['trade_date'], df.iloc[valley2_idx]['trade_date']]
            }
            structures.append(structure)

    return structures


def detect_triple_top(df, peaks_idx, period):
    """检测三重顶形态 - 使用前复权数据"""
    structures = []

    if len(peaks_idx) < 3:
        return structures

    highs = df['high_qfq'].values

    for i in range(len(peaks_idx) - 2):
        peak1_idx = peaks_idx[i]
        peak2_idx = peaks_idx[i + 1]
        peak3_idx = peaks_idx[i + 2]

        peak1_price = highs[peak1_idx]
        peak2_price = highs[peak2_idx]
        peak3_price = highs[peak3_idx]

        # 三重顶条件：三个高点都相近（差异小于3%）
        max_price = max(peak1_price, peak2_price, peak3_price)
        if (abs(peak1_price - max_price) / max_price < 0.03 and
                abs(peak2_price - max_price) / max_price < 0.03 and
                abs(peak3_price - max_price) / max_price < 0.03):
            # 计算支撑位（两个谷底的较高者）
            valley1 = df.iloc[peak1_idx:peak2_idx]['low_qfq'].min()
            valley2 = df.iloc[peak2_idx:peak3_idx]['low_qfq'].min()
            support_level = max(valley1, valley2)

            strength = calculate_pattern_strength(df, peak1_idx, peak3_idx, 'triple_top')

            structure = {
                'type': '三重顶',
                'period': period,
                'peak_prices': [peak1_price, peak2_price, peak3_price],
                'support_level': support_level,
                'strength': strength,
                'target_price': support_level - (max_price - support_level),
                'reliability': 'high' if strength > 75 else 'medium' if strength > 55 else 'low',
                'formation_dates': [df.iloc[peak1_idx]['trade_date'],
                                    df.iloc[peak2_idx]['trade_date'],
                                    df.iloc[peak3_idx]['trade_date']]
            }
            structures.append(structure)

    return structures


def detect_triple_bottom(df, valleys_idx, period):
    """检测三重底形态 - 使用前复权数据"""
    structures = []

    if len(valleys_idx) < 3:
        return structures

    lows = df['low_qfq'].values

    for i in range(len(valleys_idx) - 2):
        valley1_idx = valleys_idx[i]
        valley2_idx = valleys_idx[i + 1]
        valley3_idx = valleys_idx[i + 2]

        valley1_price = lows[valley1_idx]
        valley2_price = lows[valley2_idx]
        valley3_price = lows[valley3_idx]

        # 三重底条件：三个低点都相近（差异小于3%）
        min_price = min(valley1_price, valley2_price, valley3_price)
        if (abs(valley1_price - min_price) / min_price < 0.03 and
                abs(valley2_price - min_price) / min_price < 0.03 and
                abs(valley3_price - min_price) / min_price < 0.03):
            # 计算阻力位（两个峰顶的较低者）
            peak1 = df.iloc[valley1_idx:valley2_idx]['high_qfq'].max()
            peak2 = df.iloc[valley2_idx:valley3_idx]['high_qfq'].max()
            resistance_level = min(peak1, peak2)

            strength = calculate_pattern_strength(df, valley1_idx, valley3_idx, 'triple_bottom')

            structure = {
                'type': '三重底',
                'period': period,
                'valley_prices': [valley1_price, valley2_price, valley3_price],
                'resistance_level': resistance_level,
                'strength': strength,
                'target_price': resistance_level + (resistance_level - min_price),
                'reliability': 'high' if strength > 75 else 'medium' if strength > 55 else 'low',
                'formation_dates': [df.iloc[valley1_idx]['trade_date'],
                                    df.iloc[valley2_idx]['trade_date'],
                                    df.iloc[valley3_idx]['trade_date']]
            }
            structures.append(structure)

    return structures


def detect_head_shoulders_top(df, peaks_idx, period):
    """检测头肩顶形态 - 使用前复权数据"""
    structures = []

    if len(peaks_idx) < 3:
        return structures

    highs = df['high_qfq'].values

    for i in range(len(peaks_idx) - 2):
        left_shoulder_idx = peaks_idx[i]
        head_idx = peaks_idx[i + 1]
        right_shoulder_idx = peaks_idx[i + 2]

        left_shoulder_price = highs[left_shoulder_idx]
        head_price = highs[head_idx]
        right_shoulder_price = highs[right_shoulder_idx]

        # 头肩顶条件：头部高于两肩，两肩高度相近
        if (head_price > left_shoulder_price and head_price > right_shoulder_price and
                abs(left_shoulder_price - right_shoulder_price) / max(left_shoulder_price,
                                                                      right_shoulder_price) < 0.05):
            # 计算颈线位
            valley1 = df.iloc[left_shoulder_idx:head_idx]['low_qfq'].min()
            valley2 = df.iloc[head_idx:right_shoulder_idx]['low_qfq'].min()
            neckline = max(valley1, valley2)  # 取较高的谷底作为颈线

            strength = calculate_pattern_strength(df, left_shoulder_idx, right_shoulder_idx, 'head_shoulders_top')

            structure = {
                'type': '头肩顶',
                'period': period,
                'left_shoulder': left_shoulder_price,
                'head': head_price,
                'right_shoulder': right_shoulder_price,
                'neckline': neckline,
                'strength': strength,
                'target_price': neckline - (head_price - neckline),
                'reliability': 'high' if strength > 75 else 'medium' if strength > 55 else 'low',
                'formation_dates': [df.iloc[left_shoulder_idx]['trade_date'],
                                    df.iloc[head_idx]['trade_date'],
                                    df.iloc[right_shoulder_idx]['trade_date']]
            }
            structures.append(structure)

    return structures


def detect_head_shoulders_bottom(df, valleys_idx, period):
    """检测头肩底形态 - 使用前复权数据"""
    structures = []

    if len(valleys_idx) < 3:
        return structures

    lows = df['low_qfq'].values

    for i in range(len(valleys_idx) - 2):
        left_shoulder_idx = valleys_idx[i]
        head_idx = valleys_idx[i + 1]
        right_shoulder_idx = valleys_idx[i + 2]

        left_shoulder_price = lows[left_shoulder_idx]
        head_price = lows[head_idx]
        right_shoulder_price = lows[right_shoulder_idx]

        # 头肩底条件：头部低于两肩，两肩高度相近
        if (head_price < left_shoulder_price and head_price < right_shoulder_price and
                abs(left_shoulder_price - right_shoulder_price) / max(left_shoulder_price,
                                                                      right_shoulder_price) < 0.05):
            # 计算颈线位
            peak1 = df.iloc[left_shoulder_idx:head_idx]['high_qfq'].max()
            peak2 = df.iloc[head_idx:right_shoulder_idx]['high_qfq'].max()
            neckline = min(peak1, peak2)  # 取较低的峰顶作为颈线

            strength = calculate_pattern_strength(df, left_shoulder_idx, right_shoulder_idx, 'head_shoulders_bottom')

            structure = {
                'type': '头肩底',
                'period': period,
                'left_shoulder': left_shoulder_price,
                'head': head_price,
                'right_shoulder': right_shoulder_price,
                'neckline': neckline,
                'strength': strength,
                'target_price': neckline + (neckline - head_price),
                'reliability': 'high' if strength > 75 else 'medium' if strength > 55 else 'low',
                'formation_dates': [df.iloc[left_shoulder_idx]['trade_date'],
                                    df.iloc[head_idx]['trade_date'],
                                    df.iloc[right_shoulder_idx]['trade_date']]
            }
            structures.append(structure)

    return structures


def detect_rising_wedge(df, period):
    """检测上升楔形 - 使用前复权数据"""
    if len(df) < 15:
        return []

    # 简化的楔形检测：寻找收敛的上升趋势线
    recent_data = df.tail(15)
    highs = recent_data['high_qfq'].values
    lows = recent_data['low_qfq'].values

    # 计算趋势线斜率
    x = range(len(highs))
    high_slope = np.polyfit(x, highs, 1)[0]
    low_slope = np.polyfit(x, lows, 1)[0]

    # 上升楔形：上升趋势但高点上升斜率 < 低点上升斜率，且都在上升
    if (high_slope > 0 and low_slope > 0 and low_slope > high_slope * 1.2):
        structure = {
            'type': '上升楔形',
            'period': period,
            'high_slope': high_slope,
            'low_slope': low_slope,
            'convergence_rate': (low_slope - high_slope) / high_slope,
            'strength': 60,  # 中等强度
            'reliability': 'medium',
            'target_direction': '下跌',
            'formation_dates': [recent_data.iloc[0]['trade_date'], recent_data.iloc[-1]['trade_date']]
        }
        return [structure]

    return []


def detect_falling_wedge(df, period):
    """检测下降楔形 - 使用前复权数据"""
    if len(df) < 15:
        return []

    recent_data = df.tail(15)
    highs = recent_data['high_qfq'].values
    lows = recent_data['low_qfq'].values

    # 计算趋势线斜率
    x = range(len(highs))
    high_slope = np.polyfit(x, highs, 1)[0]
    low_slope = np.polyfit(x, lows, 1)[0]

    # 下降楔形：下降趋势但低点下降斜率 < 高点下降斜率，且都在下降
    if (high_slope < 0 and low_slope < 0 and abs(low_slope) < abs(high_slope) * 0.8):
        structure = {
            'type': '下降楔形',
            'period': period,
            'high_slope': high_slope,
            'low_slope': low_slope,
            'convergence_rate': (abs(high_slope) - abs(low_slope)) / abs(high_slope),
            'strength': 60,  # 中等强度
            'reliability': 'medium',
            'target_direction': '上涨',
            'formation_dates': [recent_data.iloc[0]['trade_date'], recent_data.iloc[-1]['trade_date']]
        }
        return [structure]

    return []


def calculate_pattern_strength(df, start_idx, end_idx, pattern_type):
    """计算形态强度"""
    base_strength = 50

    # 时间跨度加分（形成时间越长，越可靠）
    time_span = end_idx - start_idx
    time_bonus = min(time_span * 2, 20)

    # 成交量确认加分
    if 'vol' in df.columns:
        pattern_volume = df.iloc[start_idx:end_idx + 1]['vol'].mean()
        total_avg_volume = df['vol'].mean()

        if pattern_volume > total_avg_volume * 1.2:
            volume_bonus = 15
        elif pattern_volume > total_avg_volume:
            volume_bonus = 10
        else:
            volume_bonus = 0
    else:
        volume_bonus = 0

    # 价格波动率加分（适度波动更可靠）- 使用前复权数据
    pattern_data = df.iloc[start_idx:end_idx + 1]
    volatility = pattern_data['close_qfq'].std() / pattern_data['close_qfq'].mean()

    if 0.02 < volatility < 0.08:  # 适度波动
        volatility_bonus = 10
    elif volatility < 0.02:  # 波动太小
        volatility_bonus = -5
    else:  # 波动太大
        volatility_bonus = -10

    strength = base_strength + time_bonus + volume_bonus + volatility_bonus
    return min(max(strength, 0), 100)


def determine_current_structure(df, top_structures, bottom_structures):
    """判断当前所处的结构阶段 - 使用前复权数据"""
    current_price = df['close_qfq'].iloc[-1]

    # 检查是否处于已识别的形态中
    active_tops = []
    active_bottoms = []

    for structure in top_structures:
        if structure['reliability'] in ['high', 'medium']:
            active_tops.append(structure)

    for structure in bottom_structures:
        if structure['reliability'] in ['high', 'medium']:
            active_bottoms.append(structure)

    # 判断当前位置
    if active_tops:
        latest_top = max(active_tops, key=lambda x: max(x.get('formation_dates', [''])))
        if latest_top['type'] == '双顶':
            if current_price > latest_top['neckline']:
                return f"双顶形态确认中，当前在颈线{latest_top['neckline']:.2f}上方"
            else:
                return f"双顶颈线{latest_top['neckline']:.2f}已破，下跌目标{latest_top['target_price']:.2f}"
        elif latest_top['type'] == '头肩顶':
            if current_price > latest_top['neckline']:
                return f"头肩顶形态成立，警惕颈线{latest_top['neckline']:.2f}支撑"
            else:
                return f"头肩顶确认，下跌目标{latest_top['target_price']:.2f}"

    if active_bottoms:
        latest_bottom = max(active_bottoms, key=lambda x: max(x.get('formation_dates', [''])))
        if latest_bottom['type'] == '双底':
            if current_price < latest_bottom['neckline']:
                return f"双底形态确认中，当前在颈线{latest_bottom['neckline']:.2f}下方"
            else:
                return f"双底颈线{latest_bottom['neckline']:.2f}已破，上涨目标{latest_bottom['target_price']:.2f}"
        elif latest_bottom['type'] == '头肩底':
            if current_price < latest_bottom['neckline']:
                return f"头肩底形态成立，关注颈线{latest_bottom['neckline']:.2f}阻力"
            else:
                return f"头肩底确认，上涨目标{latest_bottom['target_price']:.2f}"

    # 如果没有明确形态，分析趋势
    recent_20 = df.tail(20)
    trend_change = (recent_20['close_qfq'].iloc[-1] / recent_20['close_qfq'].iloc[0] - 1) * 100

    if trend_change > 5:
        return "上升趋势中，暂无明确顶底形态"
    elif trend_change < -5:
        return "下降趋势中，暂无明确顶底形态"
    else:
        return "横盘整理中，等待形态明确"


def assess_structure_reliability(df, top_structures, bottom_structures):
    """评估结构可靠性"""
    if not top_structures and not bottom_structures:
        return 30  # 基础可靠性

    total_score = 0
    structure_count = 0

    for structure in top_structures + bottom_structures:
        if structure['reliability'] == 'high':
            total_score += 80
        elif structure['reliability'] == 'medium':
            total_score += 60
        else:
            total_score += 40
        structure_count += 1

    if structure_count == 0:
        return 30

    avg_reliability = total_score / structure_count

    # 成交量确认加分
    if 'vol' in df.columns:
        recent_volume = df.tail(10)['vol'].mean()
        overall_volume = df['vol'].mean()

        if recent_volume > overall_volume * 1.3:
            avg_reliability += 10
        elif recent_volume > overall_volume * 1.1:
            avg_reliability += 5

    return min(avg_reliability, 95)


def assess_breakout_probability(df, current_structure, reliability):
    """评估突破概率 - 使用前复权数据"""
    base_probability = 50

    # 根据结构可靠性调整
    reliability_factor = (reliability - 50) * 0.4

    # 根据当前价格位置调整
    recent_20 = df.tail(20)
    current_price = recent_20['close_qfq'].iloc[-1]
    period_high = recent_20['high_qfq'].max()
    period_low = recent_20['low_qfq'].min()

    price_position = (current_price - period_low) / (period_high - period_low) * 100

    if price_position > 80:  # 高位
        position_factor = 20  # 向上突破概率增加
    elif price_position < 20:  # 低位
        position_factor = 20  # 向下突破概率增加
    else:
        position_factor = 0

    # 成交量因素
    volume_factor = 0
    if 'vol' in df.columns:
        recent_volume = df.tail(5)['vol'].mean()
        avg_volume = df['vol'].mean()

        if recent_volume > avg_volume * 1.5:
            volume_factor = 15
        elif recent_volume > avg_volume * 1.2:
            volume_factor = 10

    breakout_probability = base_probability + reliability_factor + position_factor + volume_factor
    return min(max(breakout_probability, 10), 90)


def extract_key_levels(top_structures, bottom_structures):
    """提取关键价位"""
    key_levels = []

    for structure in top_structures:
        if structure['reliability'] in ['high', 'medium']:
            if 'neckline' in structure:
                key_levels.append({
                    'price': structure['neckline'],
                    'type': '阻力位',
                    'source': f"{structure['type']}颈线",
                    'strength': structure['strength']
                })
            if 'target_price' in structure:
                key_levels.append({
                    'price': structure['target_price'],
                    'type': '支撑目标',
                    'source': f"{structure['type']}目标",
                    'strength': structure['strength']
                })

    for structure in bottom_structures:
        if structure['reliability'] in ['high', 'medium']:
            if 'neckline' in structure:
                key_levels.append({
                    'price': structure['neckline'],
                    'type': '支撑位',
                    'source': f"{structure['type']}颈线",
                    'strength': structure['strength']
                })
            if 'target_price' in structure:
                key_levels.append({
                    'price': structure['target_price'],
                    'type': '阻力目标',
                    'source': f"{structure['type']}目标",
                    'strength': structure['strength']
                })

    # 按强度排序并去重
    key_levels.sort(key=lambda x: x['strength'], reverse=True)
    return key_levels[:8]  # 返回最重要的8个位置


def generate_structure_analysis_report(current_structure, top_structures, bottom_structures, reliability):
    """生成结构分析报告"""
    report = f"当前结构状态：{current_structure}\n\n"

    if top_structures:
        report += "🔻 识别到的顶部结构：\n"
        for i, structure in enumerate(top_structures[:3], 1):  # 只显示前3个
            report += f"{i}. {structure['type']}（{structure['period']}，可靠性：{structure['reliability']}）\n"
            if 'neckline' in structure:
                report += f"   颈线位：{structure['neckline']:.2f}\n"
            if 'target_price' in structure:
                report += f"   目标位：{structure['target_price']:.2f}\n"
        report += "\n"

    if bottom_structures:
        report += "🔺 识别到的底部结构：\n"
        for i, structure in enumerate(bottom_structures[:3], 1):  # 只显示前3个
            report += f"{i}. {structure['type']}（{structure['period']}，可靠性：{structure['reliability']}）\n"
            if 'neckline' in structure:
                report += f"   颈线位：{structure['neckline']:.2f}\n"
            if 'target_price' in structure:
                report += f"   目标位：{structure['target_price']:.2f}\n"
        report += "\n"

    report += f"结构可靠性评分：{reliability:.1f}/100\n\n"

    # 操作建议
    if reliability > 70:
        report += "📈 操作建议：结构形态清晰，可按形态理论进行操作\n"
    elif reliability > 50:
        report += "⚠️ 操作建议：结构形态一般，需结合其他指标确认\n"
    else:
        report += "🤔 操作建议：结构形态不明确，建议等待更清晰信号\n"

    return report


def calculate_td_sequential_enhanced(hist_data):
    """增强版TD序列计算 - 使用前复权数据"""
    df = hist_data.copy()
    df = df.sort_values('trade_date')

    # 初始化TD指标列
    df['td_setup'] = 0
    df['td_countdown'] = 0
    df['td_perfected'] = False
    df['td_combo'] = 0
    df['td_flip_price'] = 0.0
    df['tdst_resistance'] = 0.0
    df['tdst_support'] = 0.0
    df['td_risk_level'] = 0
    df['td_sequential_13'] = False
    df['td_pressure'] = 0
    df['td_momentum'] = 0

    # TD Setup计算
    buy_setup_count = 0
    sell_setup_count = 0
    setup_direction = 0
    setup_start_idx = 0

    # TD Countdown计算
    countdown_active = False
    countdown_type = 0
    countdown_count = 0
    countdown_start_idx = 0

    # TD Combo计算
    combo_count = 0
    combo_type = 0

    for i in range(4, len(df)):
        # 获取翻转价格（4天前的收盘价）- 使用前复权数据
        flip_price = df.iloc[i - 4]['close_qfq']
        df.iloc[i, df.columns.get_loc('td_flip_price')] = flip_price

        current_close = df.iloc[i]['close_qfq']
        current_low = df.iloc[i]['low_qfq']
        current_high = df.iloc[i]['high_qfq']

        # TD Buy Setup
        if current_close < flip_price:
            if buy_setup_count >= 0:
                buy_setup_count += 1
                sell_setup_count = 0
                df.iloc[i, df.columns.get_loc('td_setup')] = buy_setup_count
                setup_direction = 1

                if buy_setup_count == 1:
                    setup_start_idx = i

                # 检查完美设置
                if buy_setup_count == 8 or buy_setup_count == 9:
                    if i >= 7:
                        low_6 = df.iloc[i - 2]['low_qfq']
                        low_7 = df.iloc[i - 1]['low_qfq']
                        if current_low < min(low_6, low_7):
                            df.iloc[i, df.columns.get_loc('td_perfected')] = True

                # Setup 9完成
                if buy_setup_count == 9:
                    countdown_active = True
                    countdown_type = 1
                    countdown_count = 0
                    countdown_start_idx = i

                    # 计算TDST支撑线
                    setup_data = df.iloc[setup_start_idx:i + 1]
                    tdst_support = setup_data['low_qfq'].min()
                    df.iloc[i, df.columns.get_loc('tdst_support')] = tdst_support

                    # 开始Combo计数
                    combo_count = 1
                    combo_type = 1

            else:
                buy_setup_count = 1
                sell_setup_count = 0
                df.iloc[i, df.columns.get_loc('td_setup')] = buy_setup_count
                setup_direction = 1
                setup_start_idx = i

        # TD Sell Setup
        elif current_close > flip_price:
            if sell_setup_count <= 0:
                sell_setup_count -= 1
                buy_setup_count = 0
                df.iloc[i, df.columns.get_loc('td_setup')] = sell_setup_count
                setup_direction = -1

                if sell_setup_count == -1:
                    setup_start_idx = i

                # 检查完美设置
                if sell_setup_count == -8 or sell_setup_count == -9:
                    if i >= 7:
                        high_6 = df.iloc[i - 2]['high_qfq']
                        high_7 = df.iloc[i - 1]['high_qfq']
                        if current_high > max(high_6, high_7):
                            df.iloc[i, df.columns.get_loc('td_perfected')] = True

                # Setup -9完成
                if sell_setup_count == -9:
                    countdown_active = True
                    countdown_type = -1
                    countdown_count = 0
                    countdown_start_idx = i

                    # 计算TDST阻力线
                    setup_data = df.iloc[setup_start_idx:i + 1]
                    tdst_resistance = setup_data['high_qfq'].max()
                    df.iloc[i, df.columns.get_loc('tdst_resistance')] = tdst_resistance

                    # 开始Combo计数
                    combo_count = -1
                    combo_type = -1

            else:
                sell_setup_count = -1
                buy_setup_count = 0
                df.iloc[i, df.columns.get_loc('td_setup')] = sell_setup_count
                setup_direction = -1
                setup_start_idx = i
        else:
            # 价格等于翻转价格，Setup中断
            buy_setup_count = 0
            sell_setup_count = 0
            combo_count = 0

        # TD Countdown计算 - 使用前复权数据
        if countdown_active and i > countdown_start_idx and i >= 2:
            if countdown_type == 1:  # 买入倒计时
                if current_close <= df.iloc[i - 2]['low_qfq']:
                    countdown_count += 1
                    df.iloc[i, df.columns.get_loc('td_countdown')] = countdown_count

                    if countdown_count == 13:
                        df.iloc[i, df.columns.get_loc('td_sequential_13')] = True

            elif countdown_type == -1:  # 卖出倒计时
                if current_close >= df.iloc[i - 2]['high_qfq']:
                    countdown_count -= 1
                    df.iloc[i, df.columns.get_loc('td_countdown')] = countdown_count

                    if countdown_count == -13:
                        df.iloc[i, df.columns.get_loc('td_sequential_13')] = True

            # 倒计时完成
            if abs(countdown_count) >= 13:
                countdown_active = False
                countdown_count = 0

        # TD Combo计算 - 使用前复权数据
        if combo_type != 0 and i > setup_start_idx:
            if combo_type == 1 and current_close < df.iloc[i - 1]['close_qfq']:
                combo_count += 1
                df.iloc[i, df.columns.get_loc('td_combo')] = combo_count
            elif combo_type == -1 and current_close > df.iloc[i - 1]['close_qfq']:
                combo_count -= 1
                df.iloc[i, df.columns.get_loc('td_combo')] = combo_count

            if abs(combo_count) >= 13:
                combo_count = 0
                combo_type = 0

        # 计算TD压力指标（新增）- 使用前复权数据
        pressure = 0
        if i >= 9:
            recent_highs = df.iloc[i - 9:i + 1]['high_qfq'].max()
            recent_lows = df.iloc[i - 9:i + 1]['low_qfq'].min()
            if recent_highs > recent_lows:
                price_position = (current_close - recent_lows) / (recent_highs - recent_lows)
                pressure = int((1 - price_position) * 10)  # 0-10的压力级别
        df.iloc[i, df.columns.get_loc('td_pressure')] = pressure

        # 计算TD动量指标（新增）- 使用前复权数据
        momentum = 0
        if i >= 4:
            price_change = (current_close - df.iloc[i - 4]['close_qfq']) / df.iloc[i - 4]['close_qfq']
            momentum = min(max(price_change * 100, -10), 10)  # -10到+10的动量
        df.iloc[i, df.columns.get_loc('td_momentum')] = momentum

        # 计算综合TD风险等级（增强版）
        risk_level = 0

        # Setup风险
        if abs(df.iloc[i]['td_setup']) >= 7:
            risk_level += 1 * np.sign(df.iloc[i]['td_setup'])
        if abs(df.iloc[i]['td_setup']) == 9:
            risk_level += 2 * np.sign(df.iloc[i]['td_setup'])

        # Countdown风险
        if abs(df.iloc[i]['td_countdown']) >= 10:
            risk_level += 1 * np.sign(df.iloc[i]['td_countdown'])
        if abs(df.iloc[i]['td_countdown']) == 13:
            risk_level += 3 * np.sign(df.iloc[i]['td_countdown'])

        # Combo风险
        if abs(df.iloc[i]['td_combo']) >= 10:
            risk_level += 1 * np.sign(df.iloc[i]['td_combo'])

        # 压力和动量调整
        if pressure >= 8:
            risk_level -= 1
        if momentum > 5:
            risk_level += 1
        elif momentum < -5:
            risk_level -= 1

        df.iloc[i, df.columns.get_loc('td_risk_level')] = max(min(risk_level, 5), -5)

    return df


def calculate_support_resistance_enhanced(hist_data, periods=20):
    """增强版支撑阻力位计算 - 使用前复权数据"""
    df = hist_data.copy()
    df = df.sort_values('trade_date')

    recent_data = df.tail(periods)

    # 基础支撑阻力位 - 使用前复权数据
    support1 = recent_data['low_qfq'].min()
    support2 = recent_data['low_qfq'].nsmallest(2).iloc[-1] if len(recent_data) >= 2 else support1

    resistance1 = recent_data['high_qfq'].max()
    resistance2 = recent_data['high_qfq'].nlargest(2).iloc[-1] if len(recent_data) >= 2 else resistance1

    # 轴心点 - 使用前复权数据
    latest = recent_data.iloc[-1]
    pivot = (latest['high_qfq'] + latest['low_qfq'] + latest['close_qfq']) / 3

    return {
        'support1': support1,
        'support2': support2,
        'resistance1': resistance1,
        'resistance2': resistance2,
        'pivot': pivot,
        'support_strength': len(recent_data[recent_data['low_qfq'] <= support1 * 1.02]),
        'resistance_strength': len(recent_data[recent_data['high_qfq'] >= resistance1 * 0.98])
    }


def analyze_volume_pattern_enhanced(hist_data):
    """增强版成交量分析"""
    df = hist_data.copy().sort_values('trade_date')
    recent = df.tail(20)
    latest = recent.iloc[-1]

    volume_col = 'vol'

    if volume_col not in df.columns:
        return {
            'volume_trend': "数据缺失",
            'volume_ratio': 0,
            'volume_price_match': "无法分析",
            'volume_surge': False,
            'volume_consistency': 0
        }

    # 基础量比分析
    avg_volume = recent[volume_col].mean()
    recent_volume = latest[volume_col]
    volume_ratio = recent_volume / avg_volume if avg_volume > 0 else 0

    # 成交量趋势
    volume_trend = "平稳"
    volume_surge = False

    if volume_ratio > 3.0:
        volume_trend = "爆量"
        volume_surge = True
    elif volume_ratio > 2.0:
        volume_trend = "巨量"
        volume_surge = True
    elif volume_ratio > 1.5:
        volume_trend = "显著放量"
    elif volume_ratio > 1.2:
        volume_trend = "温和放量"
    elif volume_ratio < 0.5:
        volume_trend = "极度缩量"
    elif volume_ratio < 0.8:
        volume_trend = "缩量"

    # 成交量一致性（连续性）
    volume_consistency = 0
    for i in range(1, min(6, len(recent))):
        prev_ratio = recent.iloc[-i - 1][volume_col] / avg_volume
        if prev_ratio > 1.2 and volume_ratio > 1.2:
            volume_consistency += 1
        elif prev_ratio < 0.8 and volume_ratio < 0.8:
            volume_consistency += 1

    # 增强版价量配合分析
    price_change = latest['pct_chg'] if 'pct_chg' in recent.columns else 0
    volume_price_match = ""

    if price_change > 5 and volume_ratio > 2.0:
        volume_price_match = "涨停放量，强烈信号"
    elif price_change > 3 and volume_ratio > 1.5:
        volume_price_match = "放量大涨，趋势确认"
    elif price_change > 0 and volume_ratio > 1.2:
        volume_price_match = "价涨量增，趋势健康"
    elif price_change > 0 and volume_ratio < 0.8:
        volume_price_match = "价涨量缩，缺乏后劲"
    elif price_change < -5 and volume_ratio > 2.0:
        volume_price_match = "放量暴跌，恐慌杀跌"
    elif price_change < -3 and volume_ratio > 1.5:
        volume_price_match = "放量下跌，压力较大"
    elif price_change < 0 and volume_ratio < 0.8:
        volume_price_match = "缩量下跌，可能见底"
    else:
        volume_price_match = "价量配合正常"

    return {
        'volume_trend': volume_trend,
        'volume_ratio': volume_ratio,
        'volume_price_match': volume_price_match,
        'volume_surge': volume_surge,
        'volume_consistency': volume_consistency
    }


def analyze_pattern_enhanced(hist_data):
    """增强版K线形态分析 - 使用前复权数据"""
    recent = hist_data.tail(10)
    latest = recent.iloc[-1]

    if len(recent) < 3:
        return "数据不足"

    last3 = recent.tail(3)

    # 基础趋势判断 - 使用前复权数据
    if all(last3.iloc[i]['close_qfq'] > last3.iloc[i - 1]['close_qfq'] for i in range(1, 3)):
        trend = "连续上涨"
    elif all(last3.iloc[i]['close_qfq'] < last3.iloc[i - 1]['close_qfq'] for i in range(1, 3)):
        trend = "连续下跌"
    else:
        trend = "震荡整理"

    # K线形态分析 - 使用前复权数据
    body_ratio = abs(latest['close_qfq'] - latest['open_qfq']) / (latest['high_qfq'] - latest['low_qfq'] + 0.0001)
    upper_shadow = (latest['high_qfq'] - max(latest['close_qfq'], latest['open_qfq'])) / (
            latest['high_qfq'] - latest['low_qfq'] + 0.0001)
    lower_shadow = (min(latest['close_qfq'], latest['open_qfq']) - latest['low_qfq']) / (
            latest['high_qfq'] - latest['low_qfq'] + 0.0001)

    pattern = trend

    # 特殊K线形态
    if body_ratio < 0.1:
        pattern += "，十字星（变盘信号）"
    elif upper_shadow > 0.6:
        pattern += "，长上影线（上方压力大）"
    elif lower_shadow > 0.6:
        pattern += "，长下影线（下方支撑强）"
    elif latest['close_qfq'] > latest['open_qfq'] and body_ratio > 0.7:
        pattern += "，大阳线（多头强势）"
    elif latest['close_qfq'] < latest['open_qfq'] and body_ratio > 0.7:
        pattern += "，大阴线（空头强势）"

    # 根据涨幅判断强势
    if 'pct_chg' in hist_data.columns:
        pct_chg = latest['pct_chg']
        if pct_chg > 0:
            if pct_chg > 7:
                pattern += "，涨停强势"
            elif pct_chg > 5:
                pattern += "，强势上涨"
            elif pct_chg > 2:
                pattern += "，温和上涨"
        elif pct_chg < -7:
            pattern += "，跌停弱势"
        elif pct_chg < -5:
            pattern += "，急跌"

        # 判断中期趋势强度
        if len(recent) >= 5:
            recent_5 = recent.tail(5)
            up_days = sum(1 for _, row in recent_5.iterrows() if row.get('pct_chg', 0) > 0)
            total_change = recent_5['pct_chg'].sum()

            if up_days >= 4 and total_change > 5:
                pattern += "，中期强势"
            elif up_days <= 1 and total_change < -5:
                pattern += "，中期弱势"

    return pattern


def generate_enhanced_td_strategy(latest_data, sr_levels, td_setup, td_countdown,
                                  td_perfected, td_combo, tdst_support, tdst_resistance,
                                  ma_trend, volume_analysis, market_strength, atr_value):
    """生成增强版TD交易策略 - 使用前复权数据"""

    price = latest_data['close_qfq']  # 使用前复权价格
    strategy = {
        'direction': '',
        'signal_strength': '',
        'entry_points': {},
        'stop_loss': 0,
        'targets': [],
        'position_size': '',
        'time_frame': '',
        'risk_reward': '',
        'confidence': 0,
        'notes': []
    }

    # 计算动态止损（基于ATR）
    atr_stop_distance = atr_value * 2.5 if atr_value > 0 else price * 0.05

    # 综合信号强度评估（优化后标准）
    signal_score = 0
    confidence_factors = []

    # TD Setup评分（降低门槛）
    if abs(td_setup) == 9:
        signal_score += 35
        confidence_factors.append("Setup 9完成")
    elif abs(td_setup) >= 7:
        signal_score += 20
        confidence_factors.append(f"Setup {abs(td_setup)}接近完成")
    elif abs(td_setup) >= 4:
        signal_score += 12  # 提高中期Setup权重
        confidence_factors.append(f"Setup {abs(td_setup)}进行中")
    elif abs(td_setup) >= 1:
        signal_score += 5
        confidence_factors.append(f"Setup {abs(td_setup)}初期")

    # TD Countdown评分
    if abs(td_countdown) == 13:
        signal_score += 45
        confidence_factors.append("Countdown 13完成")
    elif abs(td_countdown) >= 10:
        signal_score += 30
        confidence_factors.append(f"Countdown {abs(td_countdown)}接近完成")
    elif abs(td_countdown) >= 7:
        signal_score += 20
        confidence_factors.append(f"Countdown {abs(td_countdown)}中后期")
    elif abs(td_countdown) >= 3:
        signal_score += 10
        confidence_factors.append(f"Countdown {abs(td_countdown)}进行中")

    # TD Combo评分
    if abs(td_combo) >= 10:
        signal_score += 18
        confidence_factors.append(f"Combo {abs(td_combo)}高级别")
    elif abs(td_combo) >= 5:
        signal_score += 8
        confidence_factors.append(f"Combo {abs(td_combo)}中级别")

    # 完美设置加分
    if td_perfected:
        signal_score += 20
        confidence_factors.append("完美设置确认")

    # 成交量确认（提高权重）
    if volume_analysis['volume_surge']:
        signal_score += 18
        confidence_factors.append("爆量确认")
    elif volume_analysis['volume_ratio'] > 1.5:
        signal_score += 12
        confidence_factors.append("显著放量")
    elif volume_analysis['volume_ratio'] > 1.2:
        signal_score += 8
        confidence_factors.append("温和放量")
    elif volume_analysis['volume_ratio'] < 0.8:
        signal_score -= 3
        confidence_factors.append("量能不足")

    # 均线位置加分
    if ma_trend == "多头排列":
        signal_score += 12
        confidence_factors.append("均线多头")
    elif ma_trend == "空头排列":
        signal_score -= 8
        confidence_factors.append("均线空头")

    # 市场强度调整
    if market_strength['strength_ratio'] > 0.65:
        signal_score += 8
        confidence_factors.append("市场强势")
    elif market_strength['strength_ratio'] < 0.35:
        signal_score -= 8
        confidence_factors.append("市场弱势")

    # 信号等级判定（大幅优化标准）
    if signal_score >= 70:
        strategy['signal_strength'] = "S级（极强）"
        strategy['confidence'] = min(80 + signal_score * 0.15, 95)
    elif signal_score >= 50:  # 降低门槛
        strategy['signal_strength'] = "A级（强）"
        strategy['confidence'] = min(65 + signal_score * 0.25, 85)
    elif signal_score >= 25:  # 大幅降低门槛
        strategy['signal_strength'] = "B级（中等）"
        strategy['confidence'] = min(45 + signal_score * 0.4, 70)
    elif signal_score >= 10:  # 降低门槛
        strategy['signal_strength'] = "C+级（偏弱）"
        strategy['confidence'] = min(35 + signal_score * 0.6, 55)
    else:
        strategy['signal_strength'] = "C级（弱）"
        strategy['confidence'] = min(25 + signal_score * 0.8, 45)

    # 交易方向判断（更灵活的标准）
    is_bullish_signal = (td_setup > 0 and td_setup >= 3) or (td_countdown > 0 and abs(td_countdown) >= 3)
    is_bearish_signal = (td_setup < 0 and td_setup <= -3) or (td_countdown < 0 and abs(td_countdown) >= 3)

    if is_bullish_signal or signal_score >= 20:  # 降低买入门槛
        strategy['direction'] = "买入"

        # 入场点设置（更实用）
        if signal_score >= 50:
            strategy['entry_points'] = {
                '激进': f"{price:.2f}（当前价立即入场）",
                '稳健': f"{price * 0.99:.2f}（小幅回调1%）",
                '保守': f"{max(tdst_support if tdst_support > 0 else sr_levels['support1'], sr_levels['support1']) * 1.01:.2f}（支撑位确认）"
            }
        elif signal_score >= 25:
            strategy['entry_points'] = {
                '稳健': f"{price * 0.985:.2f}（回调1.5%入场）",
                '保守': f"{sr_levels['support1'] * 1.015:.2f}（强支撑确认）"
            }
        else:
            strategy['entry_points'] = {
                '保守': f"{sr_levels['support1'] * 1.01:.2f}（支撑位企稳后试探）",
                '观察': "信号偏弱，建议小仓位试探"
            }

        # 动态止损设置
        dynamic_support = max(
            tdst_support * 0.98 if tdst_support > 0 else 0,
            sr_levels['support1'] * 0.97,
            price - atr_stop_distance
        )
        strategy['stop_loss'] = dynamic_support

        # 目标位设置（关键修复！）
        # 短线目标（3-5%）
        target1 = price * 1.035

        # 技术阻力目标
        tech_resistance = sr_levels['resistance1']
        if tdst_resistance > price * 1.02:
            tech_resistance = min(tdst_resistance, tech_resistance)
        target2 = min(tech_resistance, price * 1.08)

        # 波段目标（10-15%）
        target3 = price * 1.12
        if target2 > target3:
            target3 = target2 * 1.05

        strategy['targets'] = [
            f"T1: {target1:.2f}（+{((target1 / price - 1) * 100):.1f}%，短线）",
            f"T2: {target2:.2f}（+{((target2 / price - 1) * 100):.1f}%，技术阻力）",
            f"T3: {target3:.2f}（+{((target3 / price - 1) * 100):.1f}%，波段）"
        ]

    elif is_bearish_signal:
        strategy['direction'] = "卖出/观望"

        if signal_score >= 40:
            strategy['entry_points'] = {
                '做空': f"{price * 1.01:.2f}（反弹做空）",
                '持仓者': "考虑减仓或止盈"
            }
        else:
            strategy['entry_points'] = {
                '观望': "TD卖出信号，暂不买入",
                '持仓者': "设置止损，防范回调"
            }

        # 卖出止损
        strategy['stop_loss'] = min(
            sr_levels['resistance1'] * 1.03,
            price + atr_stop_distance
        )

        # 下跌目标位
        target1 = price * 0.965  # -3.5%
        target2 = max(sr_levels['support1'], price * 0.92)  # 技术支撑
        target3 = price * 0.88  # -12%

        strategy['targets'] = [
            f"T1: {target1:.2f}（{((target1 / price - 1) * 100):.1f}%，短线下跌）",
            f"T2: {target2:.2f}（{((target2 / price - 1) * 100):.1f}%，技术支撑）",
            f"T3: {target3:.2f}（{((target3 / price - 1) * 100):.1f}%，深度回调）"
        ]

    else:
        strategy['direction'] = "观望"

        # 观望也要设置关键位置
        strategy['entry_points'] = {
            '等待买入': f"下探{sr_levels['support1']:.2f}支撑位确认后",
            '等待卖出': f"突破{sr_levels['resistance1']:.2f}阻力位后"
        }

        # 设置关键观察位置
        upside_target = sr_levels['resistance1']
        downside_target = sr_levels['support1']

        strategy['targets'] = [
            f"上方阻力: {upside_target:.2f}（+{((upside_target / price - 1) * 100):.1f}%）",
            f"下方支撑: {downside_target:.2f}（{((downside_target / price - 1) * 100):.1f}%）",
            f"轴心点: {sr_levels['pivot']:.2f}（{((sr_levels['pivot'] / price - 1) * 100):.1f}%）"
        ]

    # 仓位管理（更实用的标准）
    if strategy['confidence'] >= 75:
        strategy['position_size'] = "50-70%（高信心重仓）"
    elif strategy['confidence'] >= 60:
        strategy['position_size'] = "40-50%（较高信心）"
    elif strategy['confidence'] >= 45:
        strategy['position_size'] = "30-40%（中等信心）"
    elif strategy['confidence'] >= 35:
        strategy['position_size'] = "20-30%（偏低信心）"
    else:
        strategy['position_size'] = "10-20%（低信心试探）"

    # 时间框架
    if abs(td_countdown) >= 8:
        strategy['time_frame'] = "中线（1-3个月）"
    elif abs(td_setup) >= 6 or signal_score >= 40:
        strategy['time_frame'] = "波段（2-4周）"
    else:
        strategy['time_frame'] = "短线（5-15天）"

    # 风险收益比计算
    if strategy['stop_loss'] > 0 and len(strategy['targets']) > 0:
        try:
            first_target = float(strategy['targets'][0].split('T1: ')[1].split('（')[0])
            risk = abs(price - strategy['stop_loss'])
            reward = abs(first_target - price)
            if risk > 0:
                rr_ratio = reward / risk
                strategy['risk_reward'] = f"1:{rr_ratio:.1f}"
            else:
                strategy['risk_reward'] = "风险极小"
        except:
            strategy['risk_reward'] = "无法计算"
    else:
        strategy['risk_reward'] = "观望状态"

    # 特殊提示
    if td_perfected:
        strategy['notes'].append("⭐ 完美设置出现，信号可靠性大幅提升")

    if abs(td_countdown) >= 11:
        strategy['notes'].append("🚨 Countdown接近完成，重点关注反转机会")

    if volume_analysis['volume_surge']:
        strategy['notes'].append("📈 成交量爆发，资金关注度高")
    elif "价涨量增" in volume_analysis['volume_price_match']:
        strategy['notes'].append("✅ 量价配合良好，趋势健康")
    elif "价跌量增" in volume_analysis['volume_price_match']:
        strategy['notes'].append("⚠️ 放量下跌，谨慎操作")

    if ma_trend == "多头排列":
        strategy['notes'].append("📊 均线多头排列，中期趋势向好")
    elif ma_trend == "空头排列":
        strategy['notes'].append("📉 均线空头排列，注意反弹高度")

    # 根据信号强度添加额外提示
    if signal_score >= 50:
        strategy['notes'].append("🎯 高质量信号，建议重点关注")
    elif signal_score >= 25:
        strategy['notes'].append("👀 中等信号，适度参与")
    else:
        strategy['notes'].append("🔍 弱信号，小仓位试探或观望")

    return strategy


def perform_td_analysis_enhanced(stock_code, stock_name, target_date):
    """增强版TD技术分析（使用新接口和前复权数据）- 并行优化版本"""
    try:
        end_date = target_date
        start_date = (pd.to_datetime(target_date) - timedelta(days=180)).strftime('%Y%m%d')

        # 使用增强版接口获取前复权数据（包含情绪指标）
        hist_data = get_enhanced_stock_data_with_emotion(stock_code, start_date, end_date)

        if len(hist_data) == 0:
            return {
                'code': stock_code,
                'name': stock_name,
                'analysis': "无法获取股票数据"
            }

        if len(hist_data) < 30:
            return {
                'code': stock_code,
                'name': stock_name,
                'analysis': "历史数据不足，无法进行完整分析"
            }

        hist_data = hist_data.sort_values('trade_date')

        # 计算均线（使用前复权数据）
        hist_data['ma5'] = hist_data['close_qfq'].rolling(window=5).mean()
        hist_data['ma10'] = hist_data['close_qfq'].rolling(window=10).mean()
        hist_data['ma20'] = hist_data['close_qfq'].rolling(window=20).mean()
        hist_data['ma60'] = hist_data['close_qfq'].rolling(window=60).mean()

        # 计算ATR
        atr_value = calculate_atr(hist_data)

        # 计算市场强度
        market_strength = calculate_market_strength(hist_data)

        # 计算增强版TD序列
        td_data = calculate_td_sequential_enhanced(hist_data)

        # 计算增强版支撑阻力位
        sr_levels = calculate_support_resistance_enhanced(hist_data)

        # 增强版成交量分析
        volume_analysis = analyze_volume_pattern_enhanced(hist_data)

        # 四维结构分析
        four_dimensional_analysis = calculate_four_dimensional_analysis(hist_data)

        # 顶底结构分析
        top_bottom_analysis = analyze_top_bottom_structure(hist_data)

        # 【新增】专业情绪分析
        emotion_analysis = calculate_emotion_analysis(hist_data)

        # 【新增】计算目标日期之后60个交易日内的最大盈利
        max_profit_result = calculate_max_profit_after_target_date(stock_code, target_date)

        # 获取最新数据
        latest = hist_data.iloc[-1]

        # 均线趋势分析（使用前复权数据）
        ma_trend = "均线粘合"
        if pd.notna(latest['ma5']) and pd.notna(latest['ma10']) and pd.notna(latest['ma20']):
            if latest['ma5'] > latest['ma10'] > latest['ma20']:
                ma_trend = "多头排列"
            elif latest['ma5'] < latest['ma10'] < latest['ma20']:
                ma_trend = "空头排列"

        # TD序列详细分析
        td_setup_current = td_data.iloc[-1]['td_setup']
        td_countdown_current = td_data.iloc[-1]['td_countdown']
        td_perfected_current = td_data.iloc[-1]['td_perfected']
        td_combo_current = td_data.iloc[-1]['td_combo']
        td_risk_current = td_data.iloc[-1]['td_risk_level']
        td_sequential_13 = td_data.iloc[-1]['td_sequential_13']
        td_pressure = td_data.iloc[-1]['td_pressure']
        td_momentum = td_data.iloc[-1]['td_momentum']
        tdst_support = td_data.iloc[-1]['tdst_support']
        tdst_resistance = td_data.iloc[-1]['tdst_resistance']

        # TD历史统计
        td_stats = {
            'setup_9_count': len(td_data[abs(td_data['td_setup']) == 9]),
            'perfected_count': len(td_data[td_data['td_perfected'] == True]),
            'countdown_13_count': len(td_data[abs(td_data['td_countdown']) == 13]),
            'sequential_13_count': len(td_data[td_data['td_sequential_13'] == True]),
            'combo_13_count': len(td_data[abs(td_data['td_combo']) == 13]),
            'current_phase': "无明显信号"
        }

        # 判断当前TD阶段
        phase_parts = []
        if abs(td_setup_current) >= 1:
            if abs(td_setup_current) <= 3:
                phase_parts.append(f"Setup初期({abs(td_setup_current)}/9)")
            elif abs(td_setup_current) <= 6:
                phase_parts.append(f"Setup中期({abs(td_setup_current)}/9)")
            elif abs(td_setup_current) <= 8:
                phase_parts.append(f"Setup后期({abs(td_setup_current)}/9)")
            elif abs(td_setup_current) == 9:
                phase_parts.append("Setup完成！")

        if abs(td_countdown_current) > 0:
            phase_parts.append(f"Countdown进行中({abs(td_countdown_current)}/13)")

        if abs(td_combo_current) > 0:
            phase_parts.append(f"Combo计数({abs(td_combo_current)}/13)")

        td_stats['current_phase'] = " + ".join(phase_parts) if phase_parts else "无明显信号"

        # 增强版形态分析
        pattern = analyze_pattern_enhanced(hist_data)

        # 生成增强版TD交易策略
        td_strategy = generate_enhanced_td_strategy(
            latest, sr_levels, td_setup_current, td_countdown_current,
            td_perfected_current, td_combo_current, tdst_support, tdst_resistance,
            ma_trend, volume_analysis, market_strength, atr_value
        )

        # 计算信号评分（用于排序）
        signal_score = 0
        if abs(td_setup_current) == 9:
            signal_score += 35
        elif abs(td_setup_current) >= 7:
            signal_score += 20
        elif abs(td_setup_current) >= 4:
            signal_score += 12
        elif abs(td_setup_current) >= 1:
            signal_score += 5

        if abs(td_countdown_current) == 13:
            signal_score += 45
        elif abs(td_countdown_current) >= 10:
            signal_score += 30
        elif abs(td_countdown_current) >= 7:
            signal_score += 20
        elif abs(td_countdown_current) >= 3:
            signal_score += 10

        if abs(td_combo_current) >= 10:
            signal_score += 18
        elif abs(td_combo_current) >= 5:
            signal_score += 8

        if td_perfected_current:
            signal_score += 20

        if volume_analysis['volume_surge']:
            signal_score += 18
        elif volume_analysis['volume_ratio'] > 1.5:
            signal_score += 12
        elif volume_analysis['volume_ratio'] > 1.2:
            signal_score += 8

        if ma_trend == "多头排列":
            signal_score += 12
        elif ma_trend == "空头排列":
            signal_score -= 8

        # 生成综合分析
        analysis = {
            'code': stock_code,
            'name': stock_name,
            'current_price': latest['close_qfq'],  # 使用前复权价格
            'ma_trend': ma_trend,
            'td_setup': td_setup_current,
            'td_countdown': td_countdown_current,
            'td_perfected': td_perfected_current,
            'td_combo': td_combo_current,
            'td_risk_level': td_risk_current,
            'td_pressure': td_pressure,
            'td_momentum': td_momentum,
            'td_phase': td_stats['current_phase'],
            'td_signal_grade': td_strategy['signal_strength'],
            'td_score': signal_score,
            'confidence': td_strategy['confidence'],
            'reversal_probability': td_strategy['confidence'],
            'tdst_levels': f"支撑: {tdst_support:.2f}, 阻力: {tdst_resistance:.2f}" if tdst_support > 0 or tdst_resistance > 0 else "暂无TDST位",
            'support_levels': f"S1: {sr_levels['support1']:.2f}, S2: {sr_levels['support2']:.2f}",
            'resistance_levels': f"R1: {sr_levels['resistance1']:.2f}, R2: {sr_levels['resistance2']:.2f}",
            'pivot': f"{sr_levels['pivot']:.2f}",
            'volume_analysis': volume_analysis,
            'pattern': pattern,
            'td_stats': td_stats,
            'td_strategy': td_strategy,
            'market_strength': market_strength,
            'atr_value': atr_value,
            'four_dimensional_analysis': four_dimensional_analysis,
            'top_bottom_analysis': top_bottom_analysis,
            'hist_data': hist_data,  # 添加历史数据
            'td_data': td_data,  # 添加TD数据
            # 【新增】60日最大盈利数据
            'max_profit_pct': max_profit_result['max_profit_pct'],
            'max_profit_days': max_profit_result['max_profit_days'],
            'max_profit_status': max_profit_result['status'],
            'max_profit_status': max_profit_result['status'],
            # 【新增】情绪分析数据
            'emotion_analysis': emotion_analysis
        }

        return analysis

    except Exception as e:
        return {
            'code': stock_code,
            'name': stock_name,
            'analysis': f"TD分析过程出错: {str(e)}"
        }


def draw_td_chart(hist_data, td_data, analysis, save_path=None):
    """
    绘制TD技术分析图表（使用前复权数据）
    """
    try:
        # 确保使用非交互式后端
        import matplotlib
        matplotlib.use('Agg')

        # 准备数据
        df = td_data.copy().sort_values('trade_date')
        df['trade_date'] = pd.to_datetime(df['trade_date'])

        # 只显示最近60个交易日
        df = df.tail(60)

        if len(df) < 10:
            print(f"数据不足，无法绘制图表")
            return None

        # 创建图表时明确指定图形对象
        plt.ioff()  # 关闭交互模式
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 12), gridspec_kw={'height_ratios': [3, 1]})
        fig.suptitle(f'{analysis["name"]} ({analysis["code"]}) - TD序列技术分析图表(前复权)',
                     fontsize=16, fontweight='bold', y=0.95)

        # 主图：K线图和TD标注（使用前复权数据）
        ax1.set_title(
            f'价格: ¥{analysis["current_price"]:.2f}(前复权) | TD Setup: {analysis["td_setup"]} | TD Countdown: {analysis["td_countdown"]} | 信号: {analysis["td_signal_grade"]}',
            fontsize=12, pad=20)

        # 绘制K线（使用前复权数据）
        for i in range(len(df)):
            row = df.iloc[i]
            date = row['trade_date']
            open_price = row['open_qfq']
            high_price = row['high_qfq']
            low_price = row['low_qfq']
            close_price = row['close_qfq']

            # K线颜色
            color = 'red' if close_price >= open_price else 'green'

            # 绘制上下影线
            ax1.plot([date, date], [low_price, high_price], color='black', linewidth=1)

            # 绘制实体
            body_height = abs(close_price - open_price)
            body_bottom = min(open_price, close_price)

            if close_price >= open_price:
                # 阳线
                rect = Rectangle((mdates.date2num(date) - 0.3, body_bottom), 0.6, body_height,
                                 facecolor='red', edgecolor='black', linewidth=0.5)
            else:
                # 阴线
                rect = Rectangle((mdates.date2num(date) - 0.3, body_bottom), 0.6, body_height,
                                 facecolor='green', edgecolor='black', linewidth=0.5)

            ax1.add_patch(rect)

        # 绘制均线（使用前复权数据）
        if 'ma5' in df.columns:
            ax1.plot(df['trade_date'], df['ma5'], label='MA5', color='purple', linewidth=1, alpha=0.8)
        if 'ma10' in df.columns:
            ax1.plot(df['trade_date'], df['ma10'], label='MA10', color='orange', linewidth=1, alpha=0.8)
        if 'ma20' in df.columns:
            ax1.plot(df['trade_date'], df['ma20'], label='MA20', color='blue', linewidth=2, alpha=0.8)

        # 标注TD Setup序号
        for i in range(len(df)):
            row = df.iloc[i]
            setup_value = row['td_setup']

            if setup_value != 0:
                date = row['trade_date']
                high_price = row['high_qfq']
                low_price = row['low_qfq']

                # 确定标注位置
                if setup_value > 0:  # 买入Setup
                    y_pos = low_price * 0.995
                    color = 'blue'
                    marker = 'o'
                else:  # 卖出Setup
                    y_pos = high_price * 1.005
                    color = 'red'
                    marker = 'v'

                # 绘制Setup序号
                ax1.scatter(date, y_pos, c=color, s=100, marker=marker, alpha=0.8, edgecolors='white', linewidths=1)
                ax1.annotate(f'{abs(setup_value)}', (date, y_pos),
                             textcoords="offset points", xytext=(0, -15 if setup_value > 0 else 15),
                             ha='center', va='center', fontsize=8, fontweight='bold', color='white',
                             bbox=dict(boxstyle="round,pad=0.3", facecolor=color, alpha=0.8))

                # Setup 9特殊标记
                if abs(setup_value) == 9:
                    ax1.annotate('Setup 9!', (date, y_pos),
                                 textcoords="offset points", xytext=(20, -30 if setup_value > 0 else 30),
                                 ha='center', va='center', fontsize=10, fontweight='bold', color=color,
                                 bbox=dict(boxstyle="round,pad=0.5", facecolor='yellow', alpha=0.8),
                                 arrowprops=dict(arrowstyle='->', color=color, lw=1.5))

        # 标注TD Countdown序号
        for i in range(len(df)):
            row = df.iloc[i]
            countdown_value = row['td_countdown']

            if countdown_value != 0:
                date = row['trade_date']
                high_price = row['high_qfq']
                low_price = row['low_qfq']

                # 确定标注位置
                if countdown_value > 0:  # 买入Countdown
                    y_pos = low_price * 0.99
                    color = 'darkblue'
                    marker = 's'
                else:  # 卖出Countdown
                    y_pos = high_price * 1.01
                    color = 'darkred'
                    marker = 's'

                # 绘制Countdown序号
                ax1.scatter(date, y_pos, c=color, s=120, marker=marker, alpha=0.9, edgecolors='white', linewidths=2)
                ax1.annotate(f'C{abs(countdown_value)}', (date, y_pos),
                             textcoords="offset points", xytext=(0, 0),
                             ha='center', va='center', fontsize=7, fontweight='bold', color='white')

                # Countdown 13特殊标记
                if abs(countdown_value) == 13:
                    ax1.annotate('Countdown 13!', (date, y_pos),
                                 textcoords="offset points", xytext=(-30, -40 if countdown_value > 0 else 40),
                                 ha='center', va='center', fontsize=11, fontweight='bold', color=color,
                                 bbox=dict(boxstyle="round,pad=0.5", facecolor='gold', alpha=0.9),
                                 arrowprops=dict(arrowstyle='->', color=color, lw=2))

        # 标注完美设置
        for i in range(len(df)):
            row = df.iloc[i]
            if row['td_perfected']:
                date = row['trade_date']
                high_price = row['high_qfq']
                ax1.annotate('★ 完美设置', (date, high_price),
                             textcoords="offset points", xytext=(10, 20),
                             ha='center', va='center', fontsize=9, fontweight='bold', color='gold',
                             bbox=dict(boxstyle="round,pad=0.3", facecolor='purple', alpha=0.8),
                             arrowprops=dict(arrowstyle='->', color='purple', lw=1.5))

        # 绘制TDST支撑阻力线
        latest_data = df.iloc[-1]
        if latest_data['tdst_support'] > 0:
            ax1.axhline(y=latest_data['tdst_support'], color='green', linestyle='--', linewidth=2, alpha=0.7,
                        label='TDST支撑')
        if latest_data['tdst_resistance'] > 0:
            ax1.axhline(y=latest_data['tdst_resistance'], color='red', linestyle='--', linewidth=2, alpha=0.7,
                        label='TDST阻力')

        # 绘制关键支撑阻力位
        support1 = float(analysis['support_levels'].split('S1: ')[1].split(',')[0])
        resistance1 = float(analysis['resistance_levels'].split('R1: ')[1].split(',')[0])

        ax1.axhline(y=support1, color='blue', linestyle=':', linewidth=1.5, alpha=0.6, label='技术支撑')
        ax1.axhline(y=resistance1, color='red', linestyle=':', linewidth=1.5, alpha=0.6, label='技术阻力')

        # 设置主图样式
        ax1.set_ylabel('价格 (¥,前复权)', fontsize=12)
        ax1.legend(loc='upper left', fontsize=10)
        ax1.grid(True, alpha=0.3)
        ax1.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d'))
        ax1.xaxis.set_major_locator(mdates.DayLocator(interval=5))

        # 成交量图
        ax2.bar(df['trade_date'], df['vol'] / 10000, width=0.8,
                color=['red' if c >= o else 'green' for c, o in zip(df['close_qfq'], df['open_qfq'])],
                alpha=0.6, label='成交量(万手)')

        # 标注放量点
        volume_avg = df['vol'].rolling(window=10).mean()
        for i in range(len(df)):
            if df.iloc[i]['vol'] > volume_avg.iloc[i] * 2:  # 放量2倍以上
                ax2.annotate('放量', (df.iloc[i]['trade_date'], df.iloc[i]['vol'] / 10000),
                             textcoords="offset points", xytext=(0, 10),
                             ha='center', va='bottom', fontsize=8, color='red', fontweight='bold')

        ax2.set_ylabel('成交量 (万手)', fontsize=12)
        ax2.set_xlabel('日期', fontsize=12)
        ax2.legend(loc='upper left', fontsize=10)
        ax2.grid(True, alpha=0.3)
        ax2.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d'))
        ax2.xaxis.set_major_locator(mdates.DayLocator(interval=5))

        # 添加分析信息文本框
        info_text = f"""TD分析信息(前复权):
• 当前阶段: {analysis['td_phase']}
• 风险等级: {analysis['td_risk_level']} (-5到+5)
• 信号评分: {analysis['td_score']}分
• 反转概率: {analysis['reversal_probability']:.1f}%
• 操作建议: {analysis['td_strategy']['direction']}
• 建议仓位: {analysis['td_strategy']['position_size']}"""

        ax1.text(0.02, 0.98, info_text, transform=ax1.transAxes, fontsize=10,
                 verticalalignment='top', bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))

        # 调整布局
        plt.tight_layout()

        # 保存图表
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight', facecolor='white')

        # 关闭图表并清理资源
        plt.close(fig)
        plt.clf()  # 清理当前图形

        return save_path

    except Exception as e:
        print(f"绘制图表时出错: {e}")
        # 确保资源清理
        try:
            plt.close('all')
            plt.clf()
        except:
            pass
        return None


def analyze_stocks_parallel(stock_data, target_date, max_workers=4):
    """并行分析股票 - 优化版本"""
    # 设置matplotlib后端
    import matplotlib
    matplotlib.use('Agg')

    analyses = []

    # ... 其余代码保持不变 ...

    def analyze_single_stock(stock_info):
        idx, stock = stock_info
        return perform_td_analysis_enhanced(stock['ts_code'], stock['name'], target_date)

    # 使用线程池并行处理
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # 提交所有任务
        futures = [
            executor.submit(analyze_single_stock, (idx, stock))
            for idx, stock in stock_data.iterrows()
        ]

        # 收集结果
        for idx, future in enumerate(as_completed(futures), 1):
            try:
                result = future.result()
                analyses.append(result)
                print(f"📊 分析进度: {idx}/{len(stock_data)} - {result.get('name', '未知股票')}")
            except Exception as e:
                print(f"分析股票时出错: {e}")
                continue

    return analyses


def create_td_charts_for_focus_stocks(analyses, target_date):
    """为重点关注股票创建TD图表"""
    # 设置matplotlib后端
    import matplotlib
    matplotlib.use('Agg')
    plt.ioff()  # 关闭交互模式

    # 创建图表保存目录
    chart_dir = f"td_charts_{target_date}_{datetime.now().strftime('%H%M%S')}"
    if not os.path.exists(chart_dir):
        os.makedirs(chart_dir)

    print(f"\n📊 开始为重点关注股票生成TD图表(前复权数据)...")

    # 筛选重点关注股票
    focus_stocks = []
    for analysis in analyses:
        if 'analysis' in analysis and isinstance(analysis['analysis'], str):
            continue

        score = analysis.get('td_score', 0)
        countdown = abs(analysis.get('td_countdown', 0))
        confidence = analysis.get('confidence', 0)

        # 筛选标准：评分≥25分 OR Countdown≥8 OR 信心度≥50%
        if score >= 25 or countdown >= 8 or confidence >= 50:
            focus_stocks.append(analysis)

    # 按评分排序，取前10只
    focus_stocks.sort(key=lambda x: x.get('td_score', 0), reverse=True)
    focus_stocks = focus_stocks[:10]

    print(f"🎯 筛选出 {len(focus_stocks)} 只重点关注股票进行图表绘制")

    chart_files = []

    for i, analysis in enumerate(focus_stocks, 1):
        try:
            print(f"📈 正在绘制 {i}/{len(focus_stocks)}: {analysis['name']}")

            # 使用已有的历史数据和TD数据
            hist_data = analysis.get('hist_data')
            td_data = analysis.get('td_data')

            if hist_data is None or td_data is None:
                print(f"⚠️ {analysis['name']} 缺少图表数据，跳过...")
                continue

            # 生成安全的图表文件名
            safe_name = analysis['name'].replace('/', '_').replace('\\', '_').replace('*', '_').replace('?',
                                                                                                        '_').replace(
                ':', '_').replace('|', '_').replace('<', '_').replace('>', '_').replace('"', '_')
            chart_filename = f"{safe_name}_{analysis['code'].replace('.', '_')}_td_chart.png"
            chart_path = os.path.join(chart_dir, chart_filename)

            # 绘制图表 - 添加异常处理
            try:
                saved_path = draw_td_chart(hist_data, td_data, analysis, chart_path)

                if saved_path:
                    chart_files.append({
                        'analysis': analysis,
                        'chart_path': saved_path,
                        'chart_filename': chart_filename,
                        'chart_dir': chart_dir
                    })

            except Exception as draw_error:
                print(f"⚠️ 绘制 {analysis['name']} 图表失败: {draw_error}")
                continue

        except Exception as e:
            print(f"❌ 处理 {analysis['name']} 时出错: {e}")
            continue

        print(f"✅ 成功生成 {len(chart_files)} 个TD图表(前复权)")
        return chart_files, chart_dir


def generate_html_report(analyses, target_date, chart_files=None):
    """生成HTML可视化报告（前复权数据版本）"""
    # 统计数据
    total_stocks = len(analyses)
    valid_analyses = [a for a in analyses if 'analysis' not in a or not isinstance(a.get('analysis'), str)]

    # 重点关注股票（优化后标准）
    focus_stocks = []
    for analysis in valid_analyses:
        score = analysis.get('td_score', 0)
        countdown = abs(analysis.get('td_countdown', 0))
        confidence = analysis.get('confidence', 0)

        # 更灵活的筛选标准
        if (score >= 20 or countdown >= 8 or confidence >= 45 or
                analysis.get('td_signal_grade', '').startswith('B') or
                analysis.get('td_signal_grade', '').startswith('A') or
                analysis.get('td_signal_grade', '').startswith('S')):
            focus_stocks.append(analysis)

    # 按综合得分排序
    focus_stocks.sort(key=lambda x: x.get('td_score', 0), reverse=True)

    # 信号等级统计
    signal_grades = {}
    for analysis in valid_analyses:
        grade = analysis.get('td_signal_grade', 'C级（弱）').split('级')[0]
        signal_grades[grade] = signal_grades.get(grade, 0) + 1

    # Setup阶段统计
    setup_stats = {'初期': 0, '中期': 0, '后期': 0, '完成': 0}
    countdown_active = 0

    for analysis in valid_analyses:
        setup = abs(analysis.get('td_setup', 0))
        countdown = abs(analysis.get('td_countdown', 0))

        if setup >= 1 and setup <= 3:
            setup_stats['初期'] += 1
        elif setup >= 4 and setup <= 6:
            setup_stats['中期'] += 1
        elif setup >= 7 and setup <= 8:
            setup_stats['后期'] += 1
        elif setup == 9:
            setup_stats['完成'] += 1

        if countdown > 0:
            countdown_active += 1

    avg_price = sum(a.get('current_price', 0) for a in valid_analyses) / len(valid_analyses) if valid_analyses else 0

    # 创建图表代码映射
    chart_map = {}
    chart_dir_name = ""
    if chart_files:
        chart_dir_name = chart_files[0]['chart_dir']
        for chart_info in chart_files:
            chart_map[chart_info['analysis']['code']] = f"{chart_dir_name}/{chart_info['chart_filename']}"

    html_content = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>增强版TD股票筛选分析报告 - {target_date}</title>
    <link rel="stylesheet" href="professional_styles.css">
    <script src="professional_scripts.js"></script>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}

        body {{
            font-family: 'Microsoft YaHei', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }}

        .container {{
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }}

        .header {{
            text-align: center;
            margin-bottom: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }}

        .header h1 {{
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }}

        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }}

        .stat-card {{
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            transform: translateY(0);
            transition: transform 0.3s ease;
        }}

        .stat-card:hover {{
            transform: translateY(-5px);
        }}

        .stat-number {{
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 8px;
        }}

        .stat-label {{
            font-size: 1rem;
            opacity: 0.9;
        }}

        .focus-section {{
            margin-bottom: 40px;
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            padding: 30px;
            border-radius: 15px;
            color: white;
        }}

        .focus-title {{
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }}

        .focus-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }}

        .focus-card {{
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }}

        /* 新增：股票名称和代码的点击样式 */
        .stock-link {{
            color: #667eea;
            text-decoration: none;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: inline-block;
        }}

        .stock-link:hover {{
            color: #ff4757;
            text-decoration: underline;
            transform: translateY(-1px);
        }}

        .stock-link::after {{
            content: '🔗';
            opacity: 0;
            margin-left: 5px;
            transition: opacity 0.3s ease;
            font-size: 0.8em;
        }}

        .stock-link:hover::after {{
            opacity: 1;
        }}

        /* 雪球跳转提示 */
        .xueqiu-tooltip {{
            position: relative;
            display: inline-block;
        }}

        .xueqiu-tooltip .tooltiptext {{
            visibility: hidden;
            width: 160px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -80px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }}

        .xueqiu-tooltip .tooltiptext::after {{
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }}

        .xueqiu-tooltip:hover .tooltiptext {{
            visibility: visible;
            opacity: 1;
        }}

        /* 优化的智能排序控制区域 */
        .sort-controls {{
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            color: white;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }}

        .sort-title {{
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }}

        .sort-subtitle {{
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            opacity: 0.9;
        }}

        .sort-buttons {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }}

        .sort-button {{
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
            overflow: hidden;
        }}

        .sort-button::before {{
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }}

        .sort-button:hover {{
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }}

        .sort-button:hover::before {{
            left: 100%;
        }}

        .sort-button.active {{
            background: rgba(255, 255, 255, 0.9);
            color: #4facfe;
            border-color: white;
            font-weight: 700;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
            transform: translateY(-3px);
        }}

        .sort-button .icon {{
            margin-right: 8px;
            font-size: 16px;
        }}

        .sort-button .arrow {{
            margin-left: 8px;
            font-size: 16px;
            transition: transform 0.3s ease;
        }}

        .sort-button.active .arrow {{
            animation: bounce 1s infinite;
        }}

        @keyframes bounce {{
            0%, 50%, 100% {{ transform: translateY(0); }}
            25% {{ transform: translateY(-3px); }}
            75% {{ transform: translateY(3px); }}
        }}

        .sort-status {{
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }}

        .sort-status .status-icon {{
            font-size: 18px;
            margin-right: 8px;
        }}

        .stock-table {{
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
        }}

        .table-header {{
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            font-size: 1.3rem;
            font-weight: 600;
        }}

        table {{
            width: 100%;
            border-collapse: collapse;
        }}

        th, td {{
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }}

        th {{
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
            position: sticky;
            top: 0;
            z-index: 10;
        }}

        /* 优化后的股票行样式 */
        .stock-row {{
            transition: all 0.3s ease;
            cursor: pointer;
        }}

        .stock-row:hover {{
            background: #f8f9fa;
            transform: translateX(5px);
        }}

        .stock-row.expanded {{
            background: #e3f2fd;
            font-weight: 600;
        }}

        /* 新增：详情行样式 */
        .detail-row {{
            display: none;
            background: #f8f9fa;
            border-left: 5px solid #667eea;
            animation: slideDown 0.5s ease-out;
        }}

        .detail-row.show {{
            display: table-row;
        }}

        .detail-content {{
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            margin: 20px;
            position: relative;
        }}

        @keyframes slideDown {{
            from {{
                opacity: 0;
                transform: translateY(-20px);
            }}
            to {{
                opacity: 1;
                transform: translateY(0);
            }}
        }}

        .detail-header {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }}

        .close-btn {{
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }}

        .close-btn:hover {{
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }}

        .analysis-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }}

        .analysis-card {{
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }}

        .analysis-card:hover {{
            transform: translateY(-3px);
            background: rgba(255, 255, 255, 0.15);
        }}

        .analysis-card h3 {{
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 8px;
        }}

        .analysis-card p {{
            margin-bottom: 8px;
            line-height: 1.5;
        }}

        .chart-section {{
            margin: 20px 0;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }}

        .chart-image {{
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            margin: 10px 0;
        }}

        .signal-badge {{
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
            text-align: center;
            min-width: 80px;
        }}

        .signal-s {{ 
            background: linear-gradient(135deg, #ff4757, #ff3742); 
            color: white; 
            box-shadow: 0 2px 10px rgba(255, 71, 87, 0.3);
        }}
        .signal-a {{ 
            background: linear-gradient(135deg, #ff7f50, #ff6348); 
            color: white; 
            box-shadow: 0 2px 10px rgba(255, 127, 80, 0.3);
        }}
        .signal-b {{ 
            background: linear-gradient(135deg, #ffa502, #ff9500); 
            color: white; 
            box-shadow: 0 2px 10px rgba(255, 165, 2, 0.3);
        }}
        .signal-c {{ 
            background: linear-gradient(135deg, #a4b0be, #9c88a4); 
            color: white; 
            box-shadow: 0 2px 10px rgba(164, 176, 190, 0.3);
        }}

        .probability-bar {{
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }}

        .probability-fill {{
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.3s ease;
        }}

        .action-button {{
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin: 2px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }}

        .action-button::before {{
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }}

        .action-button:hover {{
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }}

        .action-button:hover::before {{
            left: 100%;
        }}

        .action-button.active {{
            background: linear-gradient(135deg, #ff4757, #ff3742);
        }}

        .footer {{
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            margin-top: 40px;
        }}

        .search-box {{
            margin-bottom: 20px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            width: 100%;
            max-width: 400px;
            transition: border-color 0.3s ease;
        }}

        .search-box:focus {{
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.2);
        }}

        .back-to-top {{
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transition: all 0.3s ease;
            display: none;
        }}

        .back-to-top:hover {{
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }}

        /* 四维结构分析专用样式 */
        .four-dimensional-section {{
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
        }}

        .dimension-card {{
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }}

        .structure-badge {{
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            margin: 5px;
            display: inline-block;
        }}

        .structure-strong {{ background: #28a745; color: white; }}
        .structure-medium {{ background: #ffc107; color: black; }}
        .structure-weak {{ background: #dc3545; color: white; }}

        .level-indicator {{
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin: 2px;
        }}

        .level-high {{ background: #ff4757; color: white; }}
        .level-medium {{ background: #ffa502; color: white; }}
        .level-low {{ background: #a4b0be; color: white; }}

        /* 滚动动画 */
        .highlight-section {{
            border: 3px solid #667eea;
            border-radius: 15px;
            animation: highlightBorder 2s ease-in-out;
        }}

        @keyframes highlightBorder {{
            0% {{ border-color: #667eea; }}
            50% {{ border-color: #ff4757; }}
            100% {{ border-color: #667eea; }}
        }}

        /* 排序过渡动画 */
        .table-row-transition {{
            transition: all 0.5s ease;
        }}

        .sorting-indicator {{
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            z-index: 9999;
            display: none;
        }}

        /* 【新增】60日最大盈利相关样式 */
        .profit-badge {{
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin: 2px;
            display: inline-block;
        }}

        .profit-high {{ background: #28a745; color: white; }}
        .profit-medium {{ background: #ffc107; color: black; }}
        .profit-low {{ background: #dc3545; color: white; }}
        .profit-none {{ background: #6c757d; color: white; }}

        /* 情绪分析相关样式 */
        .emotion-badge {{
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin: 2px;
            display: inline-block;
        }}

        .emotion-乐观 {{ background: #28a745; color: white; }}
        .emotion-悲观 {{ background: #dc3545; color: white; }}
        .emotion-中性 {{ background: #6c757d; color: white; }}
        .emotion-积极 {{ background: #20c997; color: white; }}
        .emotion-消极 {{ background: #e83e8c; color: white; }}

        .emotion-section {{
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
        }}

        .emotion-positive {{ background: #28a745; color: white; }}
        .emotion-negative {{ background: #dc3545; color: white; }}
        .emotion-neutral {{ background: #6c757d; color: white; }}

        /* 总市值标识样式 */
        .market-cap-badge {{
            display: inline-block;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.875rem;
            text-align: center;
            min-width: 60px;
        }}

        .market-cap-huge {{
            background-color: #7c3aed;
            color: white;
        }}

        .market-cap-large {{
            background-color: #2563eb;
            color: white;
        }}

        .market-cap-medium {{
            background-color: #059669;
            color: white;
        }}

        .market-cap-small {{
            background-color: #dc2626;
            color: white;
        }}

        .market-cap-micro {{
            background-color: #9ca3af;
            color: white;
        }}

        .market-cap-unknown {{
            background-color: #6b7280;
            color: #f3f4f6;
        }}

        @media (max-width: 768px) {{
            .container {{
                padding: 15px;
                margin: 10px;
            }}

            .header h1 {{
                font-size: 2rem;
            }}

            .stats-grid {{
                grid-template-columns: 1fr;
            }}

            .sort-buttons {{
                grid-template-columns: 1fr;
            }}

            table {{
                font-size: 0.9rem;
            }}

            th, td {{
                padding: 10px 8px;
            }}

            .analysis-grid {{
                grid-template-columns: 1fr;
            }}

            .detail-content {{
                margin: 10px;
                padding: 20px;
            }}

            .back-to-top {{
                bottom: 20px;
                right: 20px;
                padding: 12px;
                font-size: 16px;
            }}
        }}
    </style>
    <script>
        // 全局变量
        let currentSortField = 'market_cap';
        let currentSortDirection = 'asc';
        let originalOrder = [];
        let sortingInProgress = false;
        let activeDetailRow = null;

        // 新增：雪球跳转功能
        function openXueqiu(stockCode) {{
            try {{
                // 转换股票代码格式：从 "002413.SZ" 转换为 "SZ002413"
                let xueqiuCode = '';

                if (stockCode.endsWith('.SZ')) {{
                    // 深交所股票
                    xueqiuCode = 'SZ' + stockCode.replace('.SZ', '');
                }} else if (stockCode.endsWith('.SH')) {{
                    // 上交所股票
                    xueqiuCode = 'SH' + stockCode.replace('.SH', '');
                }} else {{
                    // 其他情况直接使用原代码
                    xueqiuCode = stockCode;
                }}

                // 构建雪球URL
                const xueqiuUrl = `https://xueqiu.com/S/${{xueqiuCode}}`;

                // 在新窗口中打开雪球页面
                window.open(xueqiuUrl, '_blank');

                console.log(`✅ 已打开雪球链接: ${{xueqiuUrl}}`);

                // 显示成功提示（可选）
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 10000;
                    background: #28a745; color: white; padding: 10px 20px;
                    border-radius: 5px; font-size: 14px; opacity: 0.9;
                `;
                notification.textContent = `已打开 ${{stockCode}} 的雪球页面`;
                document.body.appendChild(notification);
                setTimeout(() => document.body.removeChild(notification), 2000);

            }} catch (error) {{
                console.error('❌ 打开雪球链接时出错:', error);
                alert(`抱歉，无法打开 ${{stockCode}} 的雪球链接，请检查网络连接。`);
            }}
        }}

        // 显示雪球跳转提示
        function showXueqiuTooltip(element, stockCode, stockName) {{
            let xueqiuCode = '';
            if (stockCode.endsWith('.SZ')) {{
                xueqiuCode = 'SZ' + stockCode.replace('.SZ', '');
            }} else if (stockCode.endsWith('.SH')) {{
                xueqiuCode = 'SH' + stockCode.replace('.SH', '');
            }} else {{
                xueqiuCode = stockCode;
            }}

            // 更新提示文本
            const tooltip = element.querySelector('.tooltiptext');
            if (tooltip) {{
                tooltip.textContent = `点击查看 ${{stockName}} 在雪球的最新信息`;
            }}
        }}

        // 排序指示器
        function showSortingIndicator(text) {{
            const indicator = document.getElementById('sortingIndicator');
            indicator.textContent = text;
            indicator.style.display = 'block';
        }}

        function hideSortingIndicator() {{
            const indicator = document.getElementById('sortingIndicator');
            indicator.style.display = 'none';
        }}

        // 搜索功能
        function searchStocks() {{
            const input = document.getElementById('searchInput');
            const filter = input.value.toUpperCase();
            const table = document.getElementById('stockTable');
            const tr = table.getElementsByTagName('tr');

            for (let i = 1; i < tr.length; i++) {{
                // 跳过详情行
                if (tr[i].classList.contains('detail-row')) {{
                    continue;
                }}

                const td = tr[i].getElementsByTagName('td')[0];
                const td2 = tr[i].getElementsByTagName('td')[1];
                if (td || td2) {{
                    const txtValue = (td.textContent || td.innerText) + (td2.textContent || td2.innerText);
                    if (txtValue.toUpperCase().indexOf(filter) > -1) {{
                        tr[i].style.display = '';
                        // 如果对应的详情行是展开的，也显示
                        const nextRow = tr[i].nextElementSibling;
                        if (nextRow && nextRow.classList.contains('detail-row') && nextRow.classList.contains('show')) {{
                            nextRow.style.display = 'table-row';
                        }}
                    }} else {{
                        tr[i].style.display = 'none';
                        // 隐藏对应的详情行
                        const nextRow = tr[i].nextElementSibling;
                        if (nextRow && nextRow.classList.contains('detail-row')) {{
                            nextRow.style.display = 'none';
                        }}
                    }}
                }}
            }}
        }}

        // 优化后的显示详情功能
        function toggleDetails(stockCode) {{
            const stockRow = document.querySelector(`[data-stock-code="${{stockCode}}"]`);
            const detailRow = document.getElementById(`detail_${{stockCode.replace('.', '_')}}`);
            const actionButton = stockRow.querySelector('.action-button');

            if (!detailRow) {{
                console.error('Detail row not found for:', stockCode);
                return;
            }}

            // 如果当前有其他展开的详情，先关闭
            if (activeDetailRow && activeDetailRow !== detailRow) {{
                activeDetailRow.classList.remove('show');
                activeDetailRow.style.display = 'none';

                // 重置之前的按钮状态
                const prevStockRow = activeDetailRow.previousElementSibling;
                if (prevStockRow) {{
                    prevStockRow.classList.remove('expanded');
                    const prevButton = prevStockRow.querySelector('.action-button');
                    if (prevButton) {{
                        prevButton.classList.remove('active');
                        prevButton.textContent = prevButton.textContent.replace('🔽 收起详情', '📋 查看详情');
                    }}
                }}
            }}

            // 切换当前详情行
            if (detailRow.classList.contains('show')) {{
                // 收起详情
                detailRow.classList.remove('show');
                detailRow.style.display = 'none';
                stockRow.classList.remove('expanded');
                actionButton.classList.remove('active');
                actionButton.textContent = actionButton.textContent.replace('🔽 收起详情', '📋 查看详情');
                activeDetailRow = null;
            }} else {{
                // 展开详情
                detailRow.classList.add('show');
                detailRow.style.display = 'table-row';
                stockRow.classList.add('expanded');
                actionButton.classList.add('active');
                actionButton.textContent = actionButton.textContent.replace('📋 查看详情', '🔽 收起详情');
                activeDetailRow = detailRow;

                // 平滑滚动到详情区域
                setTimeout(() => {{
                    detailRow.scrollIntoView({{
                        behavior: 'smooth',
                        block: 'center'
                    }});
                }}, 100);
            }}
        }}

        // 关闭详情功能
        function closeDetails(stockCode) {{
            const detailRow = document.getElementById(`detail_${{stockCode.replace('.', '_')}}`);
            const stockRow = document.querySelector(`[data-stock-code="${{stockCode}}"]`);

            if (detailRow && stockRow) {{
                detailRow.classList.remove('show');
                detailRow.style.display = 'none';
                stockRow.classList.remove('expanded');

                const actionButton = stockRow.querySelector('.action-button');
                if (actionButton) {{
                    actionButton.classList.remove('active');
                    actionButton.textContent = actionButton.textContent.replace('🔽 收起详情', '📋 查看详情');
                }}

                activeDetailRow = null;

                // 滚动回股票行
                stockRow.scrollIntoView({{
                    behavior: 'smooth',
                    block: 'center'
                }});
            }}
        }}

        // 回到顶部
        function scrollToTop() {{
            window.scrollTo({{
                top: 0,
                behavior: 'smooth'
            }});
        }}

        // 增强版智能排序功能（新增支持60日最大盈利排序）
        function smartSort(field, forceDirection = null) {{
            if (sortingInProgress) return;
            sortingInProgress = true;

            showSortingIndicator('🎛️ 智能排序中，请稍候...');

            setTimeout(() => {{
                const table = document.getElementById('stockTable');
                const tbody = table.getElementsByTagName('tbody')[0];
                const rows = Array.from(tbody.getElementsByTagName('tr'));

                // 分离股票行和详情行
                const stockRows = [];
                const detailRowsMap = new Map();

                for (let i = 0; i < rows.length; i++) {{
                    const row = rows[i];
                    if (row.classList.contains('detail-row')) {{
                        // 详情行，找到对应的股票行
                        const stockRow = rows[i - 1];
                        if (stockRow && !stockRow.classList.contains('detail-row')) {{
                            detailRowsMap.set(stockRow, row);
                        }}
                    }} else {{
                        // 股票行
                        stockRows.push(row);
                    }}
                }}

                // 确定排序方向
                let direction = forceDirection;
                if (!direction) {{
                    if (currentSortField === field) {{
                        direction = currentSortDirection === 'asc' ? 'desc' : 'asc';
                    }} else {{
                        // 默认排序方向
                        const defaultAscFields = ['price', 'market_cap'];
                        direction = defaultAscFields.includes(field) ? 'asc' : 'desc';
                    }}
                }}

                // 排序股票行
                stockRows.sort((a, b) => {{
                    let aVal, bVal;

                    switch(field) {{
                        case 'signal_grade':
                            const gradeOrder = {{'S': 4, 'A': 3, 'B': 2, 'C': 1}};
                            aVal = gradeOrder[a.dataset.signalGrade] || 0;
                            bVal = gradeOrder[b.dataset.signalGrade] || 0;
                            break;
                        case 'probability':
                            aVal = parseFloat(a.dataset.probability) || 0;
                            bVal = parseFloat(b.dataset.probability) || 0;
                            break;
                        case 'price':
                            aVal = parseFloat(a.dataset.price) || 0;
                            bVal = parseFloat(b.dataset.price) || 0;
                            break;
                        case 'market_cap':
                            aVal = parseFloat(a.dataset.marketCap) || 0;
                            bVal = parseFloat(b.dataset.marketCap) || 0;
                            break;
                        case 'td_setup':
                            aVal = Math.abs(parseInt(a.dataset.tdSetup) || 0);
                            bVal = Math.abs(parseInt(b.dataset.tdSetup) || 0);
                            break;
                        case 'td_countdown':
                            aVal = Math.abs(parseInt(a.dataset.tdCountdown) || 0);
                            bVal = Math.abs(parseInt(b.dataset.tdCountdown) || 0);
                            break;
                        case 'risk_level':
                            aVal = parseInt(a.dataset.riskLevel) || 0;
                            bVal = parseInt(b.dataset.riskLevel) || 0;
                            break;
                        case 'td_score':
                            aVal = parseInt(a.dataset.tdScore) || 0;
                            bVal = parseInt(b.dataset.tdScore) || 0;
                            break;
                        case 'max_profit':
                            aVal = parseFloat(a.dataset.maxProfit) || 0;
                            bVal = parseFloat(b.dataset.maxProfit) || 0;
                            break;
                        default:
                            return 0;
                    }}

                    if (direction === 'asc') {{
                        return aVal - bVal;
                    }} else {{
                        return bVal - aVal;
                    }}
                }});

                // 重新插入表格（带动画效果）
                tbody.style.opacity = '0.5';
                setTimeout(() => {{
                    // 清空tbody
                    tbody.innerHTML = '';

                    // 重新插入排序后的股票行和对应的详情行
                    stockRows.forEach(stockRow => {{
                        tbody.appendChild(stockRow);
                        const detailRow = detailRowsMap.get(stockRow);
                        if (detailRow) {{
                            tbody.appendChild(detailRow);
                        }}
                    }});

                    tbody.style.opacity = '1';
                }}, 300);

                // 更新状态
                currentSortField = field;
                currentSortDirection = direction;

                // 更新按钮状态
                updateSortButtons();

                // 更新排序状态显示
                updateSortStatus();

                setTimeout(() => {{
                    hideSortingIndicator();
                    sortingInProgress = false;
                }}, 800);
            }}, 200);
        }}

        // 更新排序按钮状态
        function updateSortButtons() {{
            const buttons = document.querySelectorAll('.sort-button');
            buttons.forEach(btn => {{
                btn.classList.remove('active');
                const arrow = btn.querySelector('.arrow');
                if (arrow) {{
                    arrow.textContent = '↕️';
                }}
            }});

            // 激活当前排序按钮
            const activeBtn = document.querySelector(`[data-sort="${{currentSortField}}"]`);
            if (activeBtn) {{
                activeBtn.classList.add('active');
                const arrow = activeBtn.querySelector('.arrow');
                if (arrow) {{
                    arrow.textContent = currentSortDirection === 'asc' ? '↑' : '↓';
                }}
            }}
        }}

        // 更新排序状态显示
        function updateSortStatus() {{
            const statusDiv = document.getElementById('sortStatus');
            const fieldNames = {{
                'signal_grade': '信号等级',
                'probability': '反转概率',
                'price': '股价',
                'market_cap': '总市值',
                'td_setup': 'TD Setup',
                'td_countdown': 'TD Countdown',
                'risk_level': '风险等级',
                'td_score': 'TD评分',
                'max_profit': '60日最大盈利'
            }};

            const fieldName = fieldNames[currentSortField] || currentSortField;
            const directionText = currentSortDirection === 'asc' ? '升序' : '降序';

            statusDiv.innerHTML = `<span class="status-icon">📊</span>当前排序：<strong>${{fieldName}}</strong> (${{directionText}}) | 点击任意排序按钮切换排序方式 | 🔗 点击股票名称或代码查看雪球信息`;
        }}

        // 显示/隐藏回到顶部按钮
        window.onscroll = function() {{
            const backToTopBtn = document.getElementById('backToTopBtn');
            if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {{
                backToTopBtn.style.display = 'block';
            }} else {{
                backToTopBtn.style.display = 'none';
            }}
        }};

        // 页面加载完成后的初始化
        document.addEventListener('DOMContentLoaded', function() {{
            // 保存原始顺序
            const table = document.getElementById('stockTable');
            const tbody = table.getElementsByTagName('tbody')[0];
            originalOrder = Array.from(tbody.getElementsByTagName('tr'));

            // 初始化排序状态
            updateSortButtons();
            updateSortStatus();

            console.log('🎛️ TD分析报告已加载完成！优化后的详情展示 + 8种智能排序功能 + 💼总市值筛选 + 🔗雪球跳转功能 + 💰60日最大盈利功能已启用。');

            // 初始化雪球跳转提示
            const stockLinks = document.querySelectorAll('.stock-link');
            stockLinks.forEach(link => {{
                link.addEventListener('mouseenter', function() {{
                    const stockCode = this.dataset.stockCode;
                    const stockName = this.dataset.stockName;
                    showXueqiuTooltip(this.parentElement, stockCode, stockName);
                }});
            }});

            // 添加雪球跳转使用提示
            console.log('🔗 雪球跳转功能说明：');
            console.log('• 点击股票代码或股票名称可直接跳转到雪球查看详细信息');
            console.log('• 支持深交所(.SZ)和上交所(.SH)股票');
            console.log('• 会在新标签页打开，不影响当前分析页面');
            console.log('• 悬停时显示链接图标和提示信息');

            console.log('💼 总市值筛选功能说明：');
            console.log('• 自动计算各股票的总市值（基于当前价格和模拟股本）');
            console.log('• 支持按小盘股、中盘股、大盘股等分类筛选');
            console.log('• 提供总市值升序/降序排序功能');
            console.log('• 颜色标识：紫色(超大盘)、蓝色(大盘)、绿色(中盘)、红色(小盘)、灰色(微盘)');

            console.log('💰 60日最大盈利功能说明：');
            console.log('• 计算目标日期后60个交易日内的最大盈利百分比');
            console.log('• 使用前复权数据计算，消除除权除息影响');
            console.log('• 显示达到最大盈利的天数');
            console.log('• 支持按60日最大盈利排序筛选');
        }});
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 增强版TD股票筛选分析报告</h1>
            <p>分析日期：{target_date} | 四维结构分析 + 顶底结构分析 + 优化详情展示 + 7种智能排序 + K线图表 + 🔗雪球跳转 + 💰60日最大盈利</p>
        </div>

        <!-- 排序指示器 -->
        <div id="sortingIndicator" class="sorting-indicator">
            🎛️ 智能排序中，请稍候...
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number">{total_stocks}</div>
                <div class="stat-label">总股票数量</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{len(focus_stocks)}</div>
                <div class="stat-label">重点关注股票</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{countdown_active}</div>
                <div class="stat-label">Countdown活跃</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">¥{avg_price:.2f}</div>
                <div class="stat-label">平均股价</div>
            </div>
        </div>
"""

    # 重点关注股票部分
    if focus_stocks:
        html_content += f"""
        <div class="focus-section">
            <div class="focus-title">🚨 重点关注股票 ({len(focus_stocks)}只) - 小市值低价股精选 + 🔗雪球快速跳转 + 💰60日最大盈利</div>
            <div class="focus-grid">
"""
        for stock in focus_stocks[:10]:  # 显示前10只
            chart_available = stock['code'] in chart_map
            chart_icon = "📊" if chart_available else ""

            # 60日最大盈利显示
            max_profit_pct = stock.get('max_profit_pct', 0)
            max_profit_days = stock.get('max_profit_days', 0)

            profit_display = ""
            if max_profit_pct > 0:
                profit_display = f"💰 60日最大盈利: +{max_profit_pct}% (第{max_profit_days}天)"
            else:
                profit_display = "💰 60日最大盈利: 暂无数据"

            html_content += f"""
                <div class="focus-card">
                    <h3>
                        <span class="stock-link" 
                              onclick="openXueqiu('{stock['code']}')"
                              data-stock-code="{stock['code']}"
                              data-stock-name="{stock['name']}"
                              title="点击查看雪球最新信息" 
                              style="color: white;">
                            {stock['name']} ({stock['code']})
                        </span> {chart_icon}
                    </h3>
                    <p><strong>价格：</strong>¥{stock['current_price']:.2f}</p>
                    <p><strong>Setup：</strong>{stock['td_setup']} | <strong>Countdown：</strong>{stock['td_countdown']}</p>
                    <p><strong>信号等级：</strong>{stock['td_signal_grade']}</p>
                    <p><strong>评分：</strong>{stock['td_score']}分</p>
                    <p><strong>操作建议：</strong>{stock['td_strategy']['direction']}</p>
                    <p><strong>仓位：</strong>{stock['td_strategy']['position_size']}</p>
                    <p><strong>{profit_display}</strong></p>
                    <button class="action-button" onclick="toggleDetails('{stock['code']}')">📋 查看详情{' + 图表' if chart_available else ''}</button>
                </div>
"""
        html_content += """
            </div>
        </div>
"""

    # 增强版智能排序控制区域（新增总市值排序和60日最大盈利排序）
    html_content += f"""
        <div class="sort-controls">
            <div class="sort-title">🎛️ 8种智能排序方式 + 💼总市值筛选 + 🔗雪球跳转功能 + 💰60日最大盈利</div>
            <div class="sort-subtitle">一键排序，快速筛选目标股票 | 支持升序/降序切换 | 实时排序状态显示 | 优化详情展示 | 点击股票名称跳转雪球 | 新增总市值排序和60日最大盈利排序</div>
            <div class="sort-buttons">
                <button class="sort-button" data-sort="signal_grade" onclick="smartSort('signal_grade')">
                    <span class="icon">📈</span>
                    按信号等级排序
                    <span class="arrow">↕️</span>
                </button>
                <button class="sort-button" data-sort="probability" onclick="smartSort('probability')">
                    <span class="icon">🎯</span>
                    按反转概率排序
                    <span class="arrow">↕️</span>
                </button>
                <button class="sort-button" data-sort="price" onclick="smartSort('price')">
                    <span class="icon">💰</span>
                    按股价排序
                    <span class="arrow">↕️</span>
                </button>
                <button class="sort-button" data-sort="market_cap" onclick="smartSort('market_cap')">
                    <span class="icon">💼</span>
                    按总市值排序
                    <span class="arrow">↕️</span>
                </button>
                <button class="sort-button" data-sort="td_setup" onclick="smartSort('td_setup')">
                    <span class="icon">🔢</span>
                    按TD Setup排序
                    <span class="arrow">↕️</span>
                </button>
                <button class="sort-button" data-sort="td_countdown" onclick="smartSort('td_countdown')">
                    <span class="icon">⏰</span>
                    按Countdown排序
                    <span class="arrow">↕️</span>
                </button>
                <button class="sort-button" data-sort="risk_level" onclick="smartSort('risk_level')">
                    <span class="icon">⚖️</span>
                    按风险等级排序
                    <span class="arrow">↕️</span>
                </button>
                <button class="sort-button" data-sort="max_profit" onclick="smartSort('max_profit')">
                    <span class="icon">💰</span>
                    按60日最大盈利排序
                    <span class="arrow">↕️</span>
                </button>
            </div>
            <div class="sort-status" id="sortStatus">
                <span class="status-icon">📊</span>当前排序：<strong>总市值</strong> (升序) | 点击任意排序按钮进行智能排序 | 🔗 点击股票名称或代码查看雪球信息 | 💼 新增总市值排序 + 💰 60日最大盈利排序
            </div>
        </div>
"""

    # 股票列表表格（优化后：每个股票行后紧跟详情行，新增60日最大盈利列）
    html_content += f"""
        <div class="stock-table">
            <div class="table-header">
                📊 筛选股票TD分析列表 ({len(valid_analyses)}只) - {len(chart_map)}只含K线图表 - 🎛️ 优化详情展示 + 8种智能排序 + 💼总市值筛选 + 🔗雪球跳转 + 💰60日最大盈利
            </div>
            <div style="padding: 20px;">
                <input type="text" id="searchInput" class="search-box" onkeyup="searchStocks()" 
                       placeholder="🔍 搜索股票名称或代码... (点击股票名称可跳转雪球)">
            </div>
            <table id="stockTable">
                <thead>
                    <tr>
                        <th>股票代码 🔗</th>
                        <th>股票名称 🔗</th>
                        <th>当前价格</th>
                        <th>💼总市值(亿)</th>
                        <th>TD Setup</th>
                        <th>TD Countdown</th>
                        <th>风险等级</th>
                        <th>信号等级</th>
                        <th>反转概率</th>
                        <th>💰60日最大盈利</th>
                        <th>操作建议</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody>
"""

    # 添加股票行和对应的详情行（紧密排列） - 修改这部分添加雪球跳转功能和60日最大盈利功能
    for analysis in valid_analyses:
        if 'analysis' in analysis and isinstance(analysis['analysis'], str):
            continue

        signal_class = 'signal-c'
        signal_grade_letter = 'C'
        if analysis['td_signal_grade'].startswith('S'):
            signal_class = 'signal-s'
            signal_grade_letter = 'S'
        elif analysis['td_signal_grade'].startswith('A'):
            signal_class = 'signal-a'
            signal_grade_letter = 'A'
        elif analysis['td_signal_grade'].startswith('B'):
            signal_class = 'signal-b'
            signal_grade_letter = 'B'

        risk_color = 'color: red;' if analysis['td_risk_level'] < -1 else 'color: green;' if analysis[
                                                                                                 'td_risk_level'] > 1 else 'color: gray;'

        chart_available = analysis['code'] in chart_map
        chart_icon = "📊" if chart_available else ""
        stock_id = analysis['code'].replace('.', '_')

        # 计算总市值（模拟计算，实际应用中应从数据源获取）
        try:
            # 使用股票代码生成一致的模拟股本数据
            stock_code_hash = hash(analysis['code']) % 1000000
            simulated_shares = 500000000 + (stock_code_hash * 100000)  # 5亿到15亿股
            market_cap_yi = (analysis['current_price'] * simulated_shares / 100000000)  # 转换为亿元
            market_cap_text = f"{market_cap_yi:.1f}亿"

            # 市值分类样式
            if market_cap_yi >= 1000:
                market_cap_class = 'market-cap-huge'  # 超大盘股
            elif market_cap_yi >= 500:
                market_cap_class = 'market-cap-large'  # 大盘股
            elif market_cap_yi >= 200:
                market_cap_class = 'market-cap-medium'  # 中盘股
            elif market_cap_yi >= 50:
                market_cap_class = 'market-cap-small'  # 小盘股
            else:
                market_cap_class = 'market-cap-micro'  # 微盘股

        except Exception as e:
            market_cap_yi = 0
            market_cap_text = "未知"
            market_cap_class = 'market-cap-unknown'

        # 60日最大盈利显示和样式
        max_profit_pct = analysis.get('max_profit_pct', 0)
        max_profit_days = analysis.get('max_profit_days', 0)
        max_profit_status = analysis.get('max_profit_status', 'unknown')

        if max_profit_pct > 20:
            profit_class = 'profit-high'
            profit_text = f"+{max_profit_pct}% ({max_profit_days}天)"
        elif max_profit_pct > 10:
            profit_class = 'profit-medium'
            profit_text = f"+{max_profit_pct}% ({max_profit_days}天)"
        elif max_profit_pct > 0:
            profit_class = 'profit-low'
            profit_text = f"+{max_profit_pct}% ({max_profit_days}天)"
        else:
            profit_class = 'profit-none'
            if max_profit_status == 'success':
                profit_text = "无盈利"
            else:
                profit_text = "无数据"

        # 主股票行 - 修改这部分添加雪球跳转功能、总市值和60日最大盈利数据
        html_content += f"""
                    <tr class="stock-row table-row-transition"
                        data-stock-code="{analysis['code']}"
                        data-signal-grade="{signal_grade_letter}" 
                        data-probability="{analysis['reversal_probability']}" 
                        data-price="{analysis['current_price']}"
                        data-market-cap="{market_cap_yi}"
                        data-td-setup="{analysis['td_setup']}" 
                        data-td-countdown="{analysis['td_countdown']}" 
                        data-risk-level="{analysis['td_risk_level']}"
                        data-td-score="{analysis.get('td_score', 0)}"
                        data-max-profit="{max_profit_pct}">
                        <td>
                            <div class="xueqiu-tooltip">
                                <strong class="stock-link" 
                                        onclick="openXueqiu('{analysis['code']}')"
                                        data-stock-code="{analysis['code']}"
                                        data-stock-name="{analysis['name']}"
                                        title="点击查看雪球最新信息">
                                    {analysis['code']}
                                </strong>
                                <span class="tooltiptext">点击查看 {analysis['name']} 在雪球的最新信息</span>
                            </div>
                        </td>
                        <td>
                            <div class="xueqiu-tooltip">
                                <strong class="stock-link" 
                                        onclick="openXueqiu('{analysis['code']}')"
                                        data-stock-code="{analysis['code']}"
                                        data-stock-name="{analysis['name']}"
                                        title="点击查看雪球最新信息">
                                    {analysis['name']} {chart_icon}
                                </strong>
                                <span class="tooltiptext">点击查看 {analysis['name']} 在雪球的最新信息</span>
                            </div>
                        </td>
                        <td><strong>¥{analysis['current_price']:.2f}</strong></td>
                        <td><span class="market-cap-badge {market_cap_class}">{market_cap_text}</span></td>
                        <td>{analysis['td_setup']}</td>
                        <td>{analysis['td_countdown'] if analysis['td_countdown'] != 0 else '-'}</td>
                        <td style="{risk_color}"><strong>{analysis['td_risk_level']}</strong></td>
                        <td><span class="signal-badge {signal_class}">{analysis['td_signal_grade']}</span></td>
                        <td>
                            {analysis['reversal_probability']:.1f}%
                            <div class="probability-bar">
                                <div class="probability-fill" style="width: {min(analysis['reversal_probability'], 100)}%"></div>
                            </div>
                        </td>
                        <td>
                            <span class="profit-badge {profit_class}">{profit_text}</span>
                        </td>
                        <td>
                            <strong>{analysis['td_strategy']['direction']}</strong><br>
                            <small>{analysis['td_strategy']['position_size']}</small>
                        </td>
                        <td>
                            <button class="action-button" onclick="toggleDetails('{analysis['code']}')">📋 查看详情{' + 图表' if chart_available else ''}</button>
                        </td>
                    </tr>
"""

        # 紧跟的详情行（包含完整分析内容）
        html_content += f"""
                    <tr id="detail_{stock_id}" class="detail-row">
                        <td colspan="12" style="padding: 0;">
                            <div class="detail-content">
                                <div class="detail-header">
                                    <h2>📈 
                                        <span class="stock-link" 
                                              onclick="openXueqiu('{analysis['code']}')"
                                              data-stock-code="{analysis['code']}"
                                              data-stock-name="{analysis['name']}"
                                              title="点击查看雪球最新信息"
                                              style="color: white; cursor: pointer;">
                                            {analysis['name']} ({analysis['code']})
                                        </span> - 增强版TD分析{' + K线图表' if chart_available else ''} + 🔗雪球跳转 + 💰60日最大盈利
                                    </h2>
                                    <button class="close-btn" onclick="closeDetails('{analysis['code']}')">✖ 收起</button>
                                </div>
                                <p style="margin-bottom: 25px; font-size: 1.1rem;">当前价格：¥{analysis['current_price']:.2f} | 信号等级：{analysis['td_signal_grade']} | 评分：{analysis['td_score']}分 | 💰60日最大盈利：{profit_text} | 
                                   <span class="stock-link" 
                                         onclick="openXueqiu('{analysis['code']}')"
                                         style="color: #FFD700; text-decoration: underline; cursor: pointer;"
                                         title="点击查看雪球最新信息">
                                       🔗 查看雪球详情
                                   </span>
                                </p>
"""

        # TD技术图表部分（如果有图表）
        if chart_available:
            chart_filename = chart_map[analysis['code']]
            html_content += f"""
                                <div class="chart-section">
                                    <h3>📈 TD序列K线技术图表</h3>
                                    <img src="{chart_filename}" alt="{analysis['name']} TD图表" class="chart-image" 
                                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                    <div style="display: none; padding: 20px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-align: center; border: 2px dashed rgba(255, 255, 255, 0.3);">
                                        <p>📊 图表文件未找到</p>
                                        <p>图表路径: {chart_filename}</p>
                                    </div>
                                    <div style="margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-align: left;">
                                        <h4>📋 图表说明：</h4>
                                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; margin-top: 10px;">
                                            <p>• <strong>蓝色圆点 + 数字：</strong>TD买入Setup序号 (1-9)</p>
                                            <p>• <strong>红色三角 + 数字：</strong>TD卖出Setup序号 (1-9)</p>
                                            <p>• <strong>蓝色方块 C数字：</strong>TD买入Countdown序号 (1-13)</p>
                                            <p>• <strong>红色方块 C数字：</strong>TD卖出Countdown序号 (1-13)</p>
                                            <p>• <strong>★ 完美设置：</strong>紫色标记，提高信号可靠性</p>
                                            <p>• <strong>虚线：</strong>TDST动态支撑阻力线</p>
                                            <p>• <strong>点线：</strong>传统技术支撑阻力位</p>
                                            <p>• <strong>彩色线条：</strong>MA5(紫) MA10(橙) MA20(蓝)</p>
                                        </div>
                                    </div>
                                </div>
"""

        # 分析网格（新增60日最大盈利分析卡片）
        html_content += f"""
                                <div class="analysis-grid">
                                    <div class="analysis-card">
                                        <h3>🎯 TD序列状态</h3>
                                        <p><strong>Setup：</strong>{analysis['td_setup']} {'✨完美设置' if analysis['td_perfected'] else ''}</p>
                                        <p><strong>Countdown：</strong>{analysis['td_countdown']}</p>
                                        <p><strong>Combo：</strong>{analysis['td_combo']}</p>
                                        <p><strong>当前阶段：</strong>{analysis['td_phase']}</p>
                                        <p><strong>风险等级：</strong>{analysis['td_risk_level']} (-5到+5)</p>
                                    </div>

                                    <div class="analysis-card">
                                        <h3>💰 关键价位</h3>
                                        <p><strong>支撑位：</strong>{analysis['support_levels']}</p>
                                        <p><strong>阻力位：</strong>{analysis['resistance_levels']}</p>
                                        <p><strong>轴心点：</strong>{analysis['pivot']}</p>
                                        <p><strong>TDST位：</strong>{analysis['tdst_levels']}</p>
                                    </div>

                                    <div class="analysis-card">
                                        <h3>💼 市值分析</h3>
                                        <p><strong>总市值：</strong><span class="market-cap-badge {market_cap_class}">{market_cap_text}</span></p>
                                        <p><strong>市值分类：</strong>{
        '超大盘股' if market_cap_yi >= 1000 else
        '大盘股' if market_cap_yi >= 500 else
        '中盘股' if market_cap_yi >= 200 else
        '小盘股' if market_cap_yi >= 50 else
        '微盘股'
        }</p>
                                        <p><strong>相对估值：</strong>基于当前价格计算</p>
                                        <p><strong>说明：</strong>市值数据为模拟计算，仅供参考</p>
                                    </div>

                                    <div class="analysis-card">
                                        <h3>📊 技术形态</h3>
                                        <p><strong>均线趋势：</strong>{analysis['ma_trend']}</p>
                                        <p><strong>K线形态：</strong>{analysis['pattern']}</p>
                                        <p><strong>成交量：</strong>{analysis['volume_analysis']['volume_trend']}</p>
                                        <p><strong>量价关系：</strong>{analysis['volume_analysis']['volume_price_match']}</p>
                                    </div>

                                    <div class="analysis-card">
                                        <h3>💰 60日最大盈利分析</h3>
                                        <p><strong>最大盈利：</strong><span class="profit-badge {profit_class}">{profit_text}</span></p>
                                        <p><strong>计算状态：</strong>{max_profit_status}</p>
                                        <p><strong>说明：</strong>基于目标日期后60个交易日内前复权最高价计算</p>
                                        <p><strong>风险提示：</strong>历史数据不代表未来表现</p>
                                    </div>

                                    <div class="analysis-card">
                                        <h3>🎭 情绪分析</h3>
                                        <p><strong>综合情绪：</strong><span class="emotion-badge emotion-{analysis.get('emotion_analysis', {}).get('emotion_level', '中性').replace('极度', '').replace('偏', '').lower()}">{analysis.get('emotion_analysis', {}).get('emotion_level', '中性')}({analysis.get('emotion_analysis', {}).get('emotion_score', 50)}分)</span></p>
                                        <p><strong>RSI情绪：</strong>{analysis.get('emotion_analysis', {}).get('rsi_emotion', '未知')}</p>
                                        <p><strong>MACD情绪：</strong>{analysis.get('emotion_analysis', {}).get('macd_emotion', '未知')}</p>
                                        <p><strong>资金情绪：</strong>{analysis.get('emotion_analysis', {}).get('obv_emotion', '未知')}</p>
                                    </div>

                                    <div class="analysis-card">
                                        <h3>🎯 交易策略</h3>
                                        <p><strong>操作方向：</strong>{analysis['td_strategy']['direction']}</p>
                                        <p><strong>信心等级：</strong>{analysis['td_strategy']['confidence']:.1f}%</p>
                                        <p><strong>建议仓位：</strong>{analysis['td_strategy']['position_size']}</p>
                                        <p><strong>时间框架：</strong>{analysis['td_strategy']['time_frame']}</p>
                                        <p><strong>风险收益比：</strong>{analysis['td_strategy']['risk_reward']}</p>
                                    </div>

                                    <div class="analysis-card">
                                        <h3>📍 入场点位</h3>
"""

        for level, price in analysis['td_strategy']['entry_points'].items():
            html_content += f"<p><strong>{level}：</strong>{price}</p>"

        html_content += f"""
                                    </div>

                                    <div class="analysis-card">
                                        <h3>🎯 目标位设置</h3>
                                        <p><strong>止损位：</strong>¥{analysis['td_strategy']['stop_loss']:.2f}</p>
"""

        for target in analysis['td_strategy']['targets']:
            html_content += f"<p>{target}</p>"

        html_content += """
                                    </div>
                                </div>
"""

        # 四维结构分析展示
        if analysis.get('four_dimensional_analysis'):
            four_dim = analysis['four_dimensional_analysis']
            structure_strength_class = 'structure-strong' if four_dim.get('structure_strength') in ['强',
                                                                                                    '极强'] else 'structure-medium' if four_dim.get(
                'structure_strength') == '中等' else 'structure-weak'

            html_content += f"""
                                <div class="four-dimensional-section">
                                    <h3>🔍 四维结构分析法</h3>
                                    <div style="text-align: center; margin-bottom: 20px;">
                                        <span class="structure-badge {structure_strength_class}">
                                            {four_dim.get('structure_type', '结构未明')} - {four_dim.get('structure_strength', '未知')}
                                        </span>
                                        <p style="margin-top: 10px;">综合评分：{four_dim.get('comprehensive_score', 0):.1f}/100</p>
                                    </div>

                                    <div class="analysis-grid">
                                        <div class="dimension-card">
                                            <h4>⏰ 时间维度</h4>
"""
            if 'time_dimension' in four_dim:
                time_dim = four_dim['time_dimension']
                html_content += f"""
                                            <p><strong>短期趋势（5日）：</strong>{time_dim.get('short_trend', '未知')}</p>
                                            <p><strong>中期趋势（20日）：</strong>{time_dim.get('medium_trend', '未知')}</p>
                                            <p><strong>长期趋势（60日）：</strong>{time_dim.get('long_trend', '未知')}</p>
                                            <p><strong>趋势一致性：</strong>{time_dim.get('trend_consistency', 0):.1f}%</p>
                                            <p><strong>当前位置：</strong>{time_dim.get('current_position', '未知')}</p>
                                            <p><strong>动能分析：</strong>短期{time_dim.get('momentum_5d', 0):.1f}% | 中期{time_dim.get('momentum_20d', 0):.1f}%</p>
"""
            html_content += """
                                        </div>

                                        <div class="dimension-card">
                                            <h4>💰 价格维度</h4>
"""
            if 'price_dimension' in four_dim:
                price_dim = four_dim['price_dimension']
                html_content += f"""
                                            <p><strong>价格位置：</strong>{price_dim.get('current_position_pct', 50):.1f}%（区间内）</p>
                                            <p><strong>波动率：</strong>{price_dim.get('volatility', 0):.1f}%（年化）</p>
                                            <p><strong>价格形态：</strong>{price_dim.get('price_pattern', '未识别')}</p>
                                            <p><strong>支撑级别：</strong>
"""
                for level in price_dim.get('key_support_levels', []):
                    html_content += f"<span class='level-indicator level-high'>{level:.2f}</span>"
                html_content += """</p>
                                            <p><strong>阻力级别：</strong>
"""
                for level in price_dim.get('key_resistance_levels', []):
                    html_content += f"<span class='level-indicator level-high'>{level:.2f}</span>"
            html_content += """</p>
                                        </div>

                                        <div class="dimension-card">
                                            <h4>📊 成交量维度</h4>
"""
            if 'volume_dimension' in four_dim:
                vol_dim = four_dim['volume_dimension']
                html_content += f"""
                                            <p><strong>量能趋势：</strong>{vol_dim.get('volume_trend', '未知')}</p>
                                            <p><strong>量比：</strong>{vol_dim.get('volume_ratio', 0):.2f}倍</p>
                                            <p><strong>价量相关性：</strong>{vol_dim.get('price_volume_correlation', 0):.2f}</p>
                                            <p><strong>量能异常：</strong>{vol_dim.get('volume_anomaly', '正常')}</p>
                                            <p><strong>成交分布：</strong>{vol_dim.get('volume_distribution', '未知')}</p>
"""
            html_content += """
                                        </div>

                                        <div class="dimension-card">
                                            <h4>🌐 空间维度</h4>
"""
            if 'space_dimension' in four_dim:
                space_dim = four_dim['space_dimension']
                html_content += f"""
                                            <p><strong>空间位置：</strong>{space_dim.get('current_position_pct', 50):.1f}%</p>
                                            <p><strong>日均波幅：</strong>{space_dim.get('avg_daily_range', 0):.1f}%</p>
                                            <p><strong>支撑强度：</strong>{space_dim.get('support_strength', 0):.2f}</p>
                                            <p><strong>阻力强度：</strong>{space_dim.get('resistance_strength', 0):.2f}</p>
                                            <p><strong>突破概率：</strong>{space_dim.get('breakthrough_probability', 50):.1f}%</p>
"""
            html_content += """
                                        </div>
                                    </div>
                                </div>
"""

            # 情绪分析展示
            if analysis.get('emotion_analysis'):
                emotion = analysis['emotion_analysis']
                emotion_class = 'emotion-positive' if emotion.get('emotion_score',
                                                                  50) > 60 else 'emotion-negative' if emotion.get(
                    'emotion_score', 50) < 40 else 'emotion-neutral'

                html_content += f"""
                                            <div class="emotion-section">
                                                <h3>🎭 专业情绪分析</h3>
                                                <div style="text-align: center; margin-bottom: 20px;">
                                                    <span class="emotion-badge {emotion_class}">
                                                        {emotion.get('emotion_level', '中性')} - {emotion.get('emotion_score', 50)}分
                                                    </span>
                                                </div>

                                                <div class="analysis-grid">
                                                    <div class="dimension-card">
                                                        <h4>📊 技术情绪指标</h4>
                                                        <p><strong>RSI情绪：</strong>{emotion.get('rsi_emotion', '未知')}</p>
                                                        <p><strong>CCI情绪：</strong>{emotion.get('cci_emotion', '未知')}</p>
                                                        <p><strong>KDJ情绪：</strong>{emotion.get('kdj_emotion', '未知')}</p>
                                                        <p><strong>MACD情绪：</strong>{emotion.get('macd_emotion', '未知')}</p>
                                                    </div>

                                                    <div class="dimension-card">
                                                        <h4>💰 资金情绪指标</h4>
                                                        <p><strong>PSY心理：</strong>{emotion.get('psy_emotion', '未知')}</p>
                                                        <p><strong>VR成交：</strong>{emotion.get('vr_emotion', '未知')}</p>
                                                        <p><strong>OBV资金：</strong>{emotion.get('obv_emotion', '未知')}</p>
                                                        <p><strong>MFI流量：</strong>{emotion.get('mfi_emotion', '未知')}</p>
                                                    </div>
                                                </div>

                                                <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                                    <h4>📋 专业情绪分析报告：</h4>
                                                    <div style="white-space: pre-line; line-height: 1.6;">
                                                        {emotion.get('emotion_analysis', '暂无详细分析').replace(chr(10), '<br>')}
                                                    </div>
                                                </div>
                                            </div>
            """

        # 顶底结构分析展示
        if analysis.get('top_bottom_analysis'):
            top_bottom = analysis['top_bottom_analysis']
            reliability_class = 'level-high' if top_bottom.get('structure_reliability',
                                                               0) > 70 else 'level-medium' if top_bottom.get(
                'structure_reliability', 0) > 50 else 'level-low'

            html_content += f"""
                                <div class="four-dimensional-section">
                                    <h3>🔺🔻 顶底结构分析</h3>
                                    <div style="text-align: center; margin-bottom: 20px;">
                                        <p><strong>当前结构：</strong>{top_bottom.get('current_structure', '结构不明')}</p>
                                        <span class="level-indicator {reliability_class}">可靠性：{top_bottom.get('structure_reliability', 0):.1f}%</span>
                                        <span class="level-indicator level-medium">突破概率：{top_bottom.get('breakout_probability', 50):.1f}%</span>
                                    </div>

                                    <div class="analysis-grid">
"""
            # 顶部结构
            if top_bottom.get('top_structures'):
                html_content += """
                                        <div class="dimension-card">
                                            <h4>🔻 顶部结构形态</h4>
"""
                for structure in top_bottom['top_structures'][:3]:  # 显示前3个
                    reliability_badge = 'level-high' if structure.get(
                        'reliability') == 'high' else 'level-medium' if structure.get(
                        'reliability') == 'medium' else 'level-low'
                    html_content += f"""
                                            <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                                <p><strong>{structure.get('type', '未知形态')}</strong> 
                                                   <span class="level-indicator {reliability_badge}">{structure.get('reliability', 'low')}</span></p>
                                                <p><strong>周期：</strong>{structure.get('period', '未知')}</p>
"""
                    if 'neckline' in structure:
                        html_content += f"<p><strong>颈线位：</strong>{structure['neckline']:.2f}</p>"
                    if 'target_price' in structure:
                        html_content += f"<p><strong>目标位：</strong>{structure['target_price']:.2f}</p>"
                    html_content += "</div>"
                html_content += "</div>"

            # 底部结构
            if top_bottom.get('bottom_structures'):
                html_content += """
                                        <div class="dimension-card">
                                            <h4>🔺 底部结构形态</h4>
"""
                for structure in top_bottom['bottom_structures'][:3]:  # 显示前3个
                    reliability_badge = 'level-high' if structure.get(
                        'reliability') == 'high' else 'level-medium' if structure.get(
                        'reliability') == 'medium' else 'level-low'
                    html_content += f"""
                                            <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                                <p><strong>{structure.get('type', '未知形态')}</strong> 
                                                   <span class="level-indicator {reliability_badge}">{structure.get('reliability', 'low')}</span></p>
                                                <p><strong>周期：</strong>{structure.get('period', '未知')}</p>
"""
                    if 'neckline' in structure:
                        html_content += f"<p><strong>颈线位：</strong>{structure['neckline']:.2f}</p>"
                    if 'target_price' in structure:
                        html_content += f"<p><strong>目标位：</strong>{structure['target_price']:.2f}</p>"
                    html_content += "</div>"
                html_content += "</div>"

            # 关键价位
            if top_bottom.get('key_levels'):
                html_content += """
                                        <div class="dimension-card">
                                            <h4>🎯 关键结构价位</h4>
"""
                for level in top_bottom['key_levels'][:6]:  # 显示前6个
                    level_class = 'level-high' if level.get('strength', 0) > 70 else 'level-medium' if level.get(
                        'strength', 0) > 50 else 'level-low'
                    html_content += f"""
                                            <p><span class="level-indicator {level_class}">{level.get('type', '未知')}</span> 
                                               {level.get('price', 0):.2f} ({level.get('source', '未知来源')})</p>
"""
                html_content += "</div>"

            html_content += """
                                    </div>

                                    <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                                        <h4>📋 结构分析报告：</h4>
                                        <div style="white-space: pre-line; line-height: 1.6;">
"""
            html_content += top_bottom.get('structure_analysis', '暂无详细分析').replace('\n', '<br>')
            html_content += """
                                        </div>
                                    </div>
                                </div>
"""

        # 特殊提示
        if analysis['td_strategy']['notes']:
            html_content += """
                                <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; border-left: 4px solid rgba(255, 255, 255, 0.5);">
                                    <h4>💡 特殊提示：</h4>
"""
            for note in analysis['td_strategy']['notes']:
                html_content += f"<p>• {note}</p>"
            html_content += "</div>"

        html_content += """
                            </div>
                        </td>
                    </tr>
"""

    html_content += """
                </tbody>
            </table>
        </div>
"""

    # 添加回到顶部按钮
    html_content += """
        <button id="backToTopBtn" class="back-to-top" onclick="scrollToTop()" title="回到顶部">
            ⬆️
        </button>
"""

    # 结尾
    html_content += f"""
        <div class="footer">
            <h3>📊 增强版TD分析说明 + 🔗雪球跳转功能 + 💰60日最大盈利功能</h3>
            <div style="text-align: left; max-width: 1000px; margin: 0 auto;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div>
                        <h4>🔢 TD Setup 说明：</h4>
                        <p>• 1-3：初期，观察阶段</p>
                        <p>• 4-6：中期，关注发展</p>
                        <p>• 7-8：后期，准备反转</p>
                        <p>• 9：完成，强烈反转信号</p>
                    </div>
                    <div>
                        <h4>⏰ TD Countdown 说明：</h4>
                        <p>• 1-9：倒计时进行中</p>
                        <p>• 10-12：接近完成，重点关注</p>
                        <p>• 13：倒计时完成，反转确认</p>
                    </div>
                    <div>
                        <h4>⚡ 信号等级说明：</h4>
                        <p>• S级：极强信号（≥70分）</p>
                        <p>• A级：强信号（50-69分）</p>
                        <p>• B级：中等信号（25-49分）</p>
                        <p>• C级：弱信号（<25分）</p>
                    </div>
                    <div>
                        <h4>🔗 雪球跳转功能：</h4>
                        <p>• 点击股票代码或名称跳转雪球</p>
                        <p>• 自动识别深交所(.SZ)和上交所(.SH)</p>
                        <p>• 新窗口打开，不影响当前页面</p>
                        <p>• 悬停显示跳转提示和链接图标</p>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div>
                        <h4>🎛️ 智能排序说明：</h4>
                        <p>• 📈 信号等级：S>A>B>C排序</p>
                        <p>• 🎯 反转概率：按概率高低排序</p>
                        <p>• 💰 股价：按价格高低排序</p>
                        <p>• 🔢 TD Setup：按Setup数值排序</p>
                        <p>• ⏰ Countdown：按倒计时排序</p>
                        <p>• ⚖️ 风险等级：按风险高低排序</p>
                        <p>• 💰 60日最大盈利：按盈利排序</p>
                    </div>
                    <div>
                        <h4>🔍 四维结构分析说明：</h4>
                        <p>• ⏰ 时间维度：多周期趋势一致性</p>
                        <p>• 💰 价格维度：关键价位和形态</p>
                        <p>• 📊 成交量维度：量价配合度</p>
                        <p>• 🌐 空间维度：波动空间分析</p>
                    </div>
                    <div>
                        <h4>🔺🔻 顶底结构分析说明：</h4>
                        <p>• 双顶/双底：经典反转结构</p>
                        <p>• 三重顶/底：强力反转信号</p>
                        <p>• 头肩顶/底：可靠反转形态</p>
                        <p>• 楔形：收敛突破形态</p>
                    </div>
                    <div>
                        <h4>🆕 新功能使用说明：</h4>
                        <p>• 🔗 点击股票名称/代码跳转雪球</p>
                        <p>• 📊 详情页面包含K线图表</p>
                        <p>• 🎛️ 8种排序方式快速筛选（新增总市值排序）</p>
                        <p>• 📱 完美支持移动端访问</p>
                    </div>
                    <div>
                        <h4>🎭 情绪分析功能：</h4>
                        <p>• 🎯 综合8大情绪指标：RSI、CCI、KDJ、MACD、PSY、VR、OBV、MFI</p>
                        <p>• 📊 基于前复权数据计算，确保分析准确性</p>
                        <p>• 🎭 情绪等级：极度悲观→悲观→偏悲观→中性→偏乐观→乐观→极度乐观</p>
                        <p>• 💡 提供积极信号、风险警示、机会提示</p>
                    </div>
                </div>
                <div style="margin: 30px 0; padding: 20px; background: #e3f2fd; border-radius: 10px; border-left: 5px solid #2196f3;">
                    <h4>💰 60日最大盈利功能详细说明：</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div>
                            <h5>🎯 计算方法：</h5>
                            <p>以目标日期的前复权收盘价为基准，计算后续60个交易日内前复权最高价的最大涨幅</p>
                        </div>
                        <div>
                            <h5>📅 时间范围：</h5>
                            <p>目标日期后的60个交易日（约3个月）</p>
                        </div>
                        <div>
                            <h5>🔄 数据类型：</h5>
                            <p>全程使用前复权数据，消除除权除息影响</p>
                        </div>
                        <div>
                            <h5>⚠️ 风险提示：</h5>
                            <p>历史数据不代表未来表现，仅供参考分析</p>
                        </div>
                    </div>
                    <p style="margin-top: 15px; text-align: center; font-weight: bold; color: #2196f3;">💰 示例：若目标日期股价10元，60日内最高价12元，则最大盈利为+20%</p>
                </div>
                <div style="margin: 30px 0; padding: 20px; background: #e8f5e8; border-radius: 10px; border-left: 5px solid #28a745;">
                    <h4>🔗 雪球跳转功能详细说明：</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div>
                            <h5>🎯 使用方法：</h5>
                            <p>点击任何位置的股票代码或股票名称即可跳转到雪球查看详细信息</p>
                        </div>
                        <div>
                            <h5>🔄 代码转换：</h5>
                            <p>自动将"002413.SZ"转换为雪球格式"SZ002413"</p>
                        </div>
                        <div>
                            <h5>🌐 跳转范围：</h5>
                            <p>支持深交所(.SZ)、上交所(.SH)所有A股股票</p>
                        </div>
                        <div>
                            <h5>✨ 用户体验：</h5>
                            <p>新窗口打开、悬停提示、成功通知、错误处理</p>
                        </div>
                    </div>
                    <p style="margin-top: 15px; text-align: center; font-weight: bold; color: #28a745;">🔗 示例：点击"奇科防务"或"002413.SZ"会跳转到 https://xueqiu.com/S/SZ002413</p>
                </div>
                <p><strong>🎯 风险等级：</strong>-5到-3高看空，-2到-1中等看空，0中性，+1到+2中等看多，+3到+5高看多</p>
                <br>
                <p style="color: #ff4757; font-weight: bold;">⚠️ 风险提示：以上分析仅供参考，不构成投资建议。投资有风险，入市需谨慎。</p>
                <p style="color: #2196f3; font-weight: bold;">🎛️ 使用说明：点击排序按钮快速筛选目标股票，点击"查看详情"在股票行下方展开完整分析。</p>
                <p style="color: #4facfe; font-weight: bold;">🆕 新功能：优化详情展示+四维结构分析+顶底结构分析+8种智能排序+💼总市值筛选排序+K线图表可视化+🔗雪球跳转功能+💰60日最大盈利分析。</p>
                <p style="color: #28a745; font-weight: bold;">🔗 雪球跳转：点击任何股票代码或名称可直接跳转到雪球查看最新资讯、财报、讨论等详细信息。</p>
                <p style="color: #ff6b6b; font-weight: bold;">💰 60日最大盈利：基于前复权数据计算目标日期后60个交易日内的最大涨幅，帮助评估短期盈利潜力。</p>
                <p style="color: #7c3aed; font-weight: bold;">💼 总市值功能：自动计算各股票总市值，支持按市值排序和筛选，颜色标识不同市值规模（紫色超大盘、蓝色大盘、绿色中盘、红色小盘、灰色微盘）。</p>
            </div>
        </div>
    </div>
</body>
</html>
"""

    return html_content


def get_specified_stocks_data(stock_codes, target_date=None):
    """
    获取指定股票代码的数据进行分析 - 替代原选股函数
    参数:
    - stock_codes: 股票代码列表，如 ['000001.SZ', '600000.SH']
    - target_date: 目标日期，格式YYYYMMDD
    """
    if target_date is None:
        target_date = get_latest_trade_date()

    print(f"目标日期: {target_date}")
    print(f"分析股票代码: {stock_codes}")

    # 验证股票代码格式
    valid_codes = []
    for code in stock_codes:
        if validate_stock_code(code):
            valid_codes.append(code)
        else:
            print(f"⚠️ 股票代码格式错误，已跳过: {code}")

    if not valid_codes:
        print("❌ 没有有效的股票代码")
        return pd.DataFrame()

    print(f"✅ 有效股票代码: {valid_codes}")

    # 获取股票基本信息
    print("\n第一步：获取股票基本信息...")
    all_stock_info = []

    for code in valid_codes:
        try:
            with api_lock:
                stock_info = pro.stock_basic(ts_code=code, fields='ts_code,symbol,name,area,industry,list_date')
            if len(stock_info) > 0:
                all_stock_info.append(stock_info)
                print(f"✅ {code}: {stock_info.iloc[0]['name']}")
            else:
                print(f"⚠️ 未找到股票信息: {code}")
        except Exception as e:
            print(f"❌ 获取 {code} 基本信息失败: {e}")

    if not all_stock_info:
        print("❌ 未获取到任何股票的基本信息")
        return pd.DataFrame()

    stock_list = pd.concat(all_stock_info, ignore_index=True)

    # 第二步：获取目标日的行情数据
    print(f"\n第二步：获取目标日 {target_date} 的行情数据...")
    all_daily_data = []

    for code in valid_codes:
        try:
            # 使用新接口获取前复权数据
            with api_lock:
                daily_data = pro.stk_factor_pro(**{
                    "ts_code": code,
                    "start_date": target_date,
                    "end_date": target_date,
                    "trade_date": "",
                    "limit": "",
                    "offset": ""
                }, fields=[
                    "ts_code", "trade_date", "close", "close_qfq", "pct_chg",
                    "vol", "amount", "turnover_rate", "total_mv"
                ])

            if len(daily_data) > 0:
                all_daily_data.append(daily_data)
                print(f"✅ {code}: 获取数据成功")
            else:
                print(f"⚠️ {code}: 目标日期无交易数据")

        except Exception as e:
            print(f"⚠️ 新接口获取 {code} 数据失败: {e}")
            # 备用方案：使用原接口
            try:
                with api_lock:
                    daily_data = pro.daily(ts_code=code, trade_date=target_date)
                if len(daily_data) > 0:
                    # 添加前复权字段（简化处理）
                    daily_data['close_qfq'] = daily_data['close']
                    all_daily_data.append(daily_data)
                    print(f"✅ {code}: 备用接口获取成功")
                else:
                    print(f"⚠️ {code}: 备用接口也无数据")
            except Exception as e2:
                print(f"❌ {code}: 所有接口都失败 - {e2}")

    if not all_daily_data:
        print("❌ 没有获取到任何股票的行情数据")
        return pd.DataFrame()

    # 合并所有数据
    daily_data = pd.concat(all_daily_data, ignore_index=True)
    print(f"✅ 成功获取 {len(daily_data)} 只股票的行情数据")

    # 合并股票基本信息和日线数据
    stock_data = pd.merge(stock_list, daily_data, on='ts_code', how='inner')

    # 补充获取市值和换手率数据（如果需要）
    if 'turnover_rate' not in stock_data.columns or 'total_mv' not in stock_data.columns:
        print("\n第三步：补充获取市值和换手率数据...")

        for code in valid_codes:
            try:
                with api_lock:
                    market_data = pro.daily_basic(ts_code=code,
                                                  trade_date=target_date,
                                                  fields='ts_code,turnover_rate,total_mv')
                if len(market_data) > 0:
                    # 更新对应的行
                    mask = stock_data['ts_code'] == code
                    if 'turnover_rate' not in stock_data.columns:
                        stock_data.loc[mask, 'turnover_rate'] = market_data.iloc[0]['turnover_rate']
                    if 'total_mv' not in stock_data.columns:
                        stock_data.loc[mask, 'total_mv'] = market_data.iloc[0]['total_mv']
            except Exception as e:
                print(f"⚠️ 获取 {code} 市值数据失败: {e}")

    # 确保包含前复权价格列
    if 'close_qfq' not in stock_data.columns:
        stock_data['close_qfq'] = stock_data['close']

    print(f"✅ 数据整理完成，共 {len(stock_data)} 只股票")

    # 显示股票基本信息
    display_columns = ['ts_code', 'name', 'close', 'close_qfq', 'pct_chg', 'turnover_rate', 'total_mv', 'vol', 'amount']
    available_columns = [col for col in display_columns if col in stock_data.columns]

    return stock_data[available_columns]


def validate_stock_code(code):
    """
    验证股票代码格式
    支持格式：
    - 000001.SZ（深交所）
    - 600000.SH（上交所）
    - 000001、600000（自动添加后缀）
    """
    import re

    # 如果已经有后缀，直接验证
    if '.' in code:
        pattern = r'^[0-9]{6}\.(SZ|SH)$'
        return bool(re.match(pattern, code.upper()))

    # 如果没有后缀，检查是否为6位数字
    if re.match(r'^[0-9]{6}$', code):
        return True

    return False


def normalize_stock_codes(codes):
    """
    标准化股票代码，自动添加交易所后缀
    """
    normalized = []
    for code in codes:
        code = code.strip().upper()

        if '.' in code:
            # 已经有后缀
            normalized.append(code)
        else:
            # 根据代码规则自动添加后缀
            if code.startswith(('000', '002', '003', '300')):
                # 深交所
                normalized.append(f"{code}.SZ")
            elif code.startswith(('600', '601', '603', '605', '688')):
                # 上交所
                normalized.append(f"{code}.SH")
            else:
                # 其他情况，默认深交所（用户可以手动修正）
                print(f"⚠️ 无法自动识别 {code} 的交易所，默认为深交所(.SZ)")
                normalized.append(f"{code}.SZ")

    return normalized


def format_output(df):
    """格式化输出结果（前复权版本）"""
    if len(df) == 0:
        print("\n没有找到符合条件的股票")
        return

    print("\n筛选结果（前复权数据，按市值从低到高排序）：")
    print("=" * 140)

    # 确定显示的价格列
    price_col = 'close_qfq' if 'close_qfq' in df.columns else 'close'
    price_label = '收盘价(前复权)' if 'close_qfq' in df.columns else '收盘价'

    print(f"{'序号':<5} {'股票代码':<12} {'股票名称':<10} {price_label:<12} {'涨跌幅%':<8} "
          f"{'换手率%':<8} {'总市值(亿)':<12} {'成交量(万手)':<12} {'成交额(万元)':<12}")
    print("-" * 140)

    for idx, (_, row) in enumerate(df.iterrows(), 1):
        total_mv_yi = row.get('total_mv', 0) / 10000
        vol_wan = row.get('vol', 0) / 10000 if pd.notna(row.get('vol', 0)) else 0
        amount_wan = row.get('amount', 0) / 10000 if pd.notna(row.get('amount', 0)) else 0
        turnover_rate = row.get('turnover_rate', 0) if pd.notna(row.get('turnover_rate', 0)) else 0
        pct_chg = row.get('pct_chg', 0) if pd.notna(row.get('pct_chg', 0)) else 0

        print(f"{idx:<5} {row['ts_code']:<12} {row['name']:<10} {row[price_col]:<12.2f} "
              f"{pct_chg:<8.2f} {turnover_rate:<8.2f} {total_mv_yi:<12.2f} "
              f"{vol_wan:<12.2f} {amount_wan:<12.2f}")

    print(f"\n共找到 {len(df)} 只符合条件的股票")

    # 显示统计信息
    print("\n统计信息（基于前复权数据）：")
    print(f"平均股价: {df[price_col].mean():.2f}元")
    if 'turnover_rate' in df.columns:
        print(f"平均换手率: {df['turnover_rate'].mean():.2f}%")
    if 'pct_chg' in df.columns:
        print(f"平均涨跌幅: {df['pct_chg'].mean():.2f}%")
    if 'total_mv' in df.columns:
        print(f"最小市值: {df['total_mv'].min() / 10000:.2f}亿元")
        print(f"最大市值: {df['total_mv'].max() / 10000:.2f}亿元")
        print(f"平均市值: {df['total_mv'].mean() / 10000:.2f}亿元")

    # 涨跌分布
    if 'pct_chg' in df.columns:
        up_count = len(df[df['pct_chg'] > 0])
        down_count = len(df[df['pct_chg'] < 0])
        flat_count = len(df[df['pct_chg'] == 0])
        print(f"涨跌分布: 上涨{up_count}只, 下跌{down_count}只, 平盘{flat_count}只")


def format_output_specified(df):
    """格式化输出指定股票的结果"""
    if len(df) == 0:
        print("\n❌ 没有获取到股票数据")
        return

    print("\n📊 指定股票数据（前复权）：")
    print("=" * 140)

    # 确定显示的价格列
    price_col = 'close_qfq' if 'close_qfq' in df.columns else 'close'
    price_label = '收盘价(前复权)' if 'close_qfq' in df.columns else '收盘价'

    print(f"{'序号':<5} {'股票代码':<12} {'股票名称':<10} {price_label:<12} {'涨跌幅%':<8} "
          f"{'换手率%':<8} {'总市值(亿)':<12} {'成交量(万手)':<12} {'成交额(万元)':<12}")
    print("-" * 140)

    for idx, (_, row) in enumerate(df.iterrows(), 1):
        total_mv_yi = row.get('total_mv', 0) / 10000 if pd.notna(row.get('total_mv', 0)) else 0
        vol_wan = row.get('vol', 0) / 10000 if pd.notna(row.get('vol', 0)) else 0
        amount_wan = row.get('amount', 0) / 10000 if pd.notna(row.get('amount', 0)) else 0
        turnover_rate = row.get('turnover_rate', 0) if pd.notna(row.get('turnover_rate', 0)) else 0
        pct_chg = row.get('pct_chg', 0) if pd.notna(row.get('pct_chg', 0)) else 0

        print(f"{idx:<5} {row['ts_code']:<12} {row['name']:<10} {row[price_col]:<12.2f} "
              f"{pct_chg:<8.2f} {turnover_rate:<8.2f} {total_mv_yi:<12.2f} "
              f"{vol_wan:<12.2f} {amount_wan:<12.2f}")

    print(f"\n✅ 共获取 {len(df)} 只指定股票的数据")

    # 显示统计信息
    print("\n📈 统计信息：")
    if len(df) > 1:
        print(f"平均股价: {df[price_col].mean():.2f}元")
        if 'turnover_rate' in df.columns:
            print(f"平均换手率: {df['turnover_rate'].mean():.2f}%")
        if 'pct_chg' in df.columns:
            print(f"平均涨跌幅: {df['pct_chg'].mean():.2f}%")
        if 'total_mv' in df.columns:
            print(f"总市值范围: {df['total_mv'].min() / 10000:.2f}亿 - {df['total_mv'].max() / 10000:.2f}亿")

    # 涨跌分布
    if 'pct_chg' in df.columns:
        up_count = len(df[df['pct_chg'] > 0])
        down_count = len(df[df['pct_chg'] < 0])
        flat_count = len(df[df['pct_chg'] == 0])
        print(f"涨跌分布: 上涨{up_count}只, 下跌{down_count}只, 平盘{flat_count}只")


def create_td_charts_for_specified_stocks(analyses, target_date):
    """为指定股票创建TD图表"""
    # 设置matplotlib后端
    import matplotlib
    matplotlib.use('Agg')
    plt.ioff()

    # 创建图表保存目录
    chart_dir = f"指定股票td_charts_{target_date}_{datetime.now().strftime('%H%M%S')}"
    if not os.path.exists(chart_dir):
        os.makedirs(chart_dir)

    print(f"\n📊 开始为指定股票生成TD图表...")

    chart_files = []

    for i, analysis in enumerate(analyses, 1):
        try:
            if 'analysis' in analysis and isinstance(analysis['analysis'], str):
                print(f"⚠️ {analysis.get('name', 'Unknown')}: {analysis['analysis']}")
                continue

            print(f"📈 正在绘制 {i}/{len(analyses)}: {analysis['name']}")

            # 使用已有的历史数据和TD数据
            hist_data = analysis.get('hist_data')
            td_data = analysis.get('td_data')

            if hist_data is None or td_data is None:
                print(f"⚠️ {analysis['name']} 缺少图表数据，跳过...")
                continue

            # 生成安全的图表文件名
            safe_name = analysis['name'].replace('/', '_').replace('\\', '_').replace('*', '_').replace('?',
                                                                                                        '_').replace(
                ':', '_').replace('|', '_').replace('<', '_').replace('>', '_').replace('"', '_')
            chart_filename = f"{safe_name}_{analysis['code'].replace('.', '_')}_td_chart.png"
            chart_path = os.path.join(chart_dir, chart_filename)

            # 绘制图表
            try:
                saved_path = draw_td_chart(hist_data, td_data, analysis, chart_path)

                if saved_path:
                    chart_files.append({
                        'analysis': analysis,
                        'chart_path': saved_path,
                        'chart_filename': chart_filename,
                        'chart_dir': chart_dir
                    })

            except Exception as draw_error:
                print(f"⚠️ 绘制 {analysis['name']} 图表失败: {draw_error}")
                continue

        except Exception as e:
            print(f"❌ 处理 {analysis.get('name', 'Unknown')} 时出错: {e}")
            continue

    print(f"✅ 成功生成 {len(chart_files)} 个TD图表")
    return chart_files, chart_dir


def batch_analyze_specified_stocks(stock_codes, start_date, end_date):
    """批量分析指定股票在日期区间内的表现"""
    print(f"\n🔍 获取 {start_date} 到 {end_date} 期间的交易日...")

    # 设置matplotlib后端
    import matplotlib
    matplotlib.use('Agg')

    # 获取交易日列表
    trade_dates = get_trade_dates_in_range(start_date, end_date)

    if not trade_dates:
        print("❌ 未找到交易日或获取交易日历失败")
        input("按回车键退出...")
        return

    print(f"📅 找到 {len(trade_dates)} 个交易日")
    print(f"📊 将分析股票: {', '.join(stock_codes)}")

    # 确认是否继续
    estimated_time = len(trade_dates) * len(stock_codes) * 0.5  # 估算时间（分钟）
    print(f"\n⚠️ 批量分析将处理 {len(trade_dates)} 个交易日 × {len(stock_codes)} 只股票")
    print(f"预计耗时：{estimated_time:.0f}-{estimated_time * 2:.0f} 分钟")
    confirm = input("是否继续？(Y/N): ").strip().upper()

    if confirm != 'Y':
        print("已取消批量分析")
        input("按回车键退出...")
        return

    print(f"\n🚀 开始批量分析...")
    print("=" * 80)

    successful_analyses = []
    failed_analyses = []
    html_files = []

    for i, target_date in enumerate(trade_dates, 1):
        print(f"\n📊 正在分析第 {i}/{len(trade_dates)} 个交易日：{target_date}")
        print(f"进度：{i / len(trade_dates) * 100:.1f}%")
        print("-" * 60)

        try:
            # 获取指定股票数据
            result = get_specified_stocks_data(stock_codes, target_date)

            if len(result) > 0:
                print(f"✅ {target_date} 获取数据成功，{len(result)} 只股票有数据")

                # 保存CSV
                csv_filename = f"指定股票批量分析_{target_date}_{datetime.now().strftime('%H%M%S')}.csv"
                result.to_csv(csv_filename, index=False, encoding='utf-8-sig')

                # 执行TD分析
                print(f"🔄 开始TD技术分析...")
                max_workers = min(4, len(result))
                analyses = analyze_stocks_parallel(result, target_date, max_workers)

                # 生成图表
                chart_files = []
                chart_dir = None
                try:
                    chart_files, chart_dir = create_td_charts_for_specified_stocks(analyses, target_date)
                except Exception as chart_error:
                    print(f"⚠️ 图表生成失败: {chart_error}")

                # 生成HTML报告
                html_content = generate_html_report(analyses, target_date, chart_files)
                html_filename = f"指定股票批量分析报告_{target_date}_{datetime.now().strftime('%H%M%S')}.html"

                with open(html_filename, 'w', encoding='utf-8') as f:
                    f.write(html_content)

                print(f"📊 HTML报告已保存: {html_filename}")

                successful_analyses.append({
                    'date': target_date,
                    'stock_count': len(result),
                    'csv_file': csv_filename,
                    'html_file': html_filename,
                    'chart_dir': chart_dir if chart_files else None,
                    'chart_count': len(chart_files) if chart_files else 0
                })

                html_files.append(html_filename)

            else:
                print(f"⚠️ {target_date} 指定股票无交易数据")
                failed_analyses.append({
                    'date': target_date,
                    'reason': '指定股票无交易数据'
                })

        except Exception as e:
            print(f"❌ {target_date} 分析失败: {e}")
            failed_analyses.append({
                'date': target_date,
                'reason': str(e)
            })

        # 添加延迟
        if i < len(trade_dates):
            time.sleep(2)

    # 显示结果汇总
    print("\n" + "=" * 80)
    print("🎉 批量分析完成！")
    print("=" * 80)

    print(f"\n📊 分析汇总：")
    print(f"总交易日数：{len(trade_dates)}")
    print(f"成功分析：{len(successful_analyses)} 个")
    print(f"失败分析：{len(failed_analyses)} 个")
    print(f"成功率：{len(successful_analyses) / len(trade_dates) * 100:.1f}%")

    if successful_analyses:
        total_stocks = sum(analysis['stock_count'] for analysis in successful_analyses)
        total_charts = sum(analysis['chart_count'] for analysis in successful_analyses)

        print(f"\n📈 统计信息：")
        print(f"  总数据记录数：{total_stocks} 条")
        print(f"  总生成图表数：{total_charts} 个")

    # 询问是否打开报告
    if html_files:
        print(f"\n🌐 是否依次打开所有HTML报告？({len(html_files)} 个文件)")
        open_reports = input("是否打开？(Y/N): ").strip().upper()

        if open_reports == 'Y':
            for i, html_file in enumerate(html_files, 1):
                try:
                    webbrowser.open(f'file://{os.path.abspath(html_file)}')
                    print(f"✅ 已打开第 {i}/{len(html_files)} 个报告: {html_file}")
                    if i < len(html_files):
                        time.sleep(2)
                except Exception as e:
                    print(f"❌ 无法打开 {html_file}: {e}")

    print(f"\n✅ 批量分析全部完成！")
    input("按回车键退出...")

def get_trade_dates_in_range(start_date, end_date):
    """获取日期区间内的所有交易日"""
    try:
        with api_lock:
            trade_cal = pro.trade_cal(exchange='SSE', start_date=start_date, end_date=end_date, is_open=1)
        trade_dates = trade_cal.sort_values('cal_date')['cal_date'].tolist()
        return trade_dates
    except Exception as e:
        print(f"获取交易日历出错: {e}")
        return []


def batch_analyze_dates(start_date, end_date):
    """批量分析日期区间内的所有交易日"""
    print(f"\n🔍 获取 {start_date} 到 {end_date} 期间的交易日...")

    # 设置matplotlib后端
    import matplotlib
    matplotlib.use('Agg')

    # 获取交易日列表
    trade_dates = get_trade_dates_in_range(start_date, end_date)

    if not trade_dates:
        print("❌ 未找到交易日或获取交易日历失败")
        input("\n按回车键退出程序...")
        return

    print(f"📅 找到 {len(trade_dates)} 个交易日：")
    for i, date in enumerate(trade_dates, 1):
        print(f"  {i}. {date}")

    # 确认是否继续
    print(
        f"\n⚠️ 批量分析将处理 {len(trade_dates)} 个交易日，预计耗时：{len(trade_dates) * 3:.0f}-{len(trade_dates) * 8:.0f} 分钟")
    confirm = input("是否继续？(Y/N): ").strip().upper()

    if confirm != 'Y':
        print("已取消批量分析")
        input("\n按回车键退出程序...")
        return

    print(f"\n🚀 开始批量分析...")
    print("=" * 80)

    successful_analyses = []
    failed_analyses = []
    html_files = []

    for i, target_date in enumerate(trade_dates, 1):
        print(f"\n📊 正在分析第 {i}/{len(trade_dates)} 个交易日：{target_date}")
        print(f"进度：{i / len(trade_dates) * 100:.1f}%")
        print("-" * 60)

        try:
            # 执行单日分析
            result = stock_selector(target_date)

            if len(result) > 0:
                print(f"✅ {target_date} 筛选完成，找到 {len(result)} 只股票")

                # 保存CSV
                csv_filename = f"批量TD筛选_{target_date}_{datetime.now().strftime('%H%M%S')}.csv"
                result.to_csv(csv_filename, index=False, encoding='utf-8-sig')
                print(f"📄 CSV已保存: {csv_filename}")

                # 执行TD分析
                print(f"🔄 开始TD技术分析...")
                max_workers = min(4, len(result))
                analyses = analyze_stocks_parallel(result, target_date, max_workers)

                # 生成图表 - 添加异常处理
                chart_files = []
                chart_dir = None
                try:
                    print(f"📈 开始生成图表...")
                    chart_files, chart_dir = create_td_charts_for_focus_stocks(analyses, target_date)
                    print(f"✅ 图表生成完成: {len(chart_files)} 个")
                except Exception as chart_error:
                    print(f"⚠️ 图表生成失败: {chart_error}")
                    print("继续生成HTML报告...")

                # 生成HTML报告
                html_content = generate_html_report(analyses, target_date, chart_files)
                html_filename = f"批量TD分析报告_{target_date}_{datetime.now().strftime('%H%M%S')}.html"

                with open(html_filename, 'w', encoding='utf-8') as f:
                    f.write(html_content)

                print(f"📊 HTML报告已保存: {html_filename}")

                successful_analyses.append({
                    'date': target_date,
                    'stock_count': len(result),
                    'csv_file': csv_filename,
                    'html_file': html_filename,
                    'chart_dir': chart_dir if chart_files else None,
                    'chart_count': len(chart_files) if chart_files else 0
                })

                html_files.append(html_filename)

            else:
                print(f"⚠️ {target_date} 未找到符合条件的股票")
                failed_analyses.append({
                    'date': target_date,
                    'reason': '未找到符合条件的股票'
                })

        except Exception as e:
            print(f"❌ {target_date} 分析失败: {e}")
            failed_analyses.append({
                'date': target_date,
                'reason': str(e)
            })

        # 添加延迟避免API限制
        if i < len(trade_dates):
            print("⏳ 等待3秒后继续下一个交易日...")
            time.sleep(3)

    # 显示批量分析结果汇总
    print("\n" + "=" * 80)
    print("🎉 批量分析完成！")
    print("=" * 80)

    print(f"\n📊 分析汇总：")
    print(f"总交易日数：{len(trade_dates)}")
    print(f"成功分析：{len(successful_analyses)} 个")
    print(f"失败分析：{len(failed_analyses)} 个")
    print(f"成功率：{len(successful_analyses) / len(trade_dates) * 100:.1f}%")

    if successful_analyses:
        print(f"\n✅ 成功分析的交易日：")
        total_stocks = 0
        total_charts = 0

        for analysis in successful_analyses:
            print(f"  📅 {analysis['date']}: {analysis['stock_count']} 只股票, {analysis['chart_count']} 个图表")
            total_stocks += analysis['stock_count']
            total_charts += analysis['chart_count']

        print(f"\n📈 统计信息：")
        print(f"  总筛选股票数：{total_stocks} 只")
        print(f"  总生成图表数：{total_charts} 个")
        print(f"  平均每日股票数：{total_stocks / len(successful_analyses):.1f} 只")

        print(f"\n📁 生成的文件：")
        for analysis in successful_analyses:
            print(f"  📊 {analysis['html_file']}")
            print(f"  📄 {analysis['csv_file']}")
            if analysis['chart_dir']:
                print(f"  📈 图表目录: {analysis['chart_dir']}")
            print()

    if failed_analyses:
        print(f"\n❌ 失败分析的交易日：")
        for analysis in failed_analyses:
            print(f"  📅 {analysis['date']}: {analysis['reason']}")

    # 询问是否依次打开HTML报告
    if html_files:
        print(f"\n🌐 是否依次打开所有HTML报告？({len(html_files)} 个文件)")
        print("注意：这将打开多个浏览器标签页")
        open_reports = input("是否打开？(Y/N): ").strip().upper()

        if open_reports == 'Y':
            print(f"\n🌐 正在依次打开HTML报告...")

            for i, html_file in enumerate(html_files, 1):
                try:
                    webbrowser.open(f'file://{os.path.abspath(html_file)}')
                    print(f"✅ 已打开第 {i}/{len(html_files)} 个报告: {html_file}")

                    # 添加延迟避免浏览器卡顿
                    if i < len(html_files):
                        time.sleep(2)

                except Exception as e:
                    print(f"❌ 无法打开 {html_file}: {e}")

            print(f"\n🎉 已尝试打开所有 {len(html_files)} 个HTML报告！")
        else:
            print(f"\n📝 HTML报告文件列表：")
            for html_file in html_files:
                print(f"  📊 {os.path.abspath(html_file)}")

    # 生成批量分析汇总报告
    if successful_analyses:
        print(f"\n📋 正在生成批量分析汇总报告...")
        summary_html = generate_batch_summary_report(successful_analyses, failed_analyses, start_date, end_date)
        summary_filename = f"批量分析汇总报告_{start_date}到{end_date}_{datetime.now().strftime('%H%M%S')}.html"

        with open(summary_filename, 'w', encoding='utf-8') as f:
            f.write(summary_html)

        print(f"📋 汇总报告已保存: {summary_filename}")

        # 打开汇总报告
        try:
            webbrowser.open(f'file://{os.path.abspath(summary_filename)}')
            print(f"🌐 已自动打开汇总报告")
        except:
            print(f"❌ 无法自动打开汇总报告，请手动打开：{summary_filename}")

    print(f"\n✅ 批量分析全部完成！")
    input("\n按回车键退出程序...")


def generate_batch_summary_report(successful_analyses, failed_analyses, start_date, end_date):
    """生成批量分析汇总报告"""
    total_dates = len(successful_analyses) + len(failed_analyses)
    success_rate = len(successful_analyses) / total_dates * 100 if total_dates > 0 else 0
    total_stocks = sum(analysis['stock_count'] for analysis in successful_analyses)
    total_charts = sum(analysis['chart_count'] for analysis in successful_analyses)

    html_content = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>批量TD分析汇总报告 - {start_date}到{end_date}</title>
    <style>
        body {{
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }}
        .header {{
            text-align: center;
            margin-bottom: 40px;
        }}
        .header h1 {{
            font-size: 2.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }}
        .stats-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }}
        .stat-card {{
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }}
        .stat-number {{
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }}
        .stat-label {{
            font-size: 1rem;
            opacity: 0.9;
        }}
        .analysis-table {{
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }}
        .table-header {{
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            font-size: 1.3rem;
            font-weight: 600;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
        }}
        th, td {{
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }}
        th {{
            background: #f8f9fa;
            font-weight: 600;
        }}
        .success-row {{
            background: #f8fff8;
        }}
        .failed-row {{
            background: #fff8f8;
        }}
        .file-link {{
            color: #667eea;
            text-decoration: none;
            font-weight: bold;
        }}
        .file-link:hover {{
            text-decoration: underline;
        }}
        .summary-section {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 批量TD分析汇总报告</h1>
            <p>分析期间：{start_date} - {end_date} | 生成时间：{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number">{total_dates}</div>
                <div class="stat-label">总交易日数</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{len(successful_analyses)}</div>
                <div class="stat-label">成功分析</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{success_rate:.1f}%</div>
                <div class="stat-label">成功率</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{total_stocks}</div>
                <div class="stat-label">总筛选股票</div>
            </div>
            <div class="stat-card">
                <div class="stat-number">{total_charts}</div>
                <div class="stat-label">总生成图表</div>
            </div>
        </div>

        <div class="analysis-table">
            <div class="table-header">📊 详细分析结果</div>
            <table>
                <thead>
                    <tr>
                        <th>交易日期</th>
                        <th>状态</th>
                        <th>筛选股票数</th>
                        <th>生成图表数</th>
                        <th>HTML报告</th>
                        <th>CSV数据</th>
                        <th>图表目录</th>
                    </tr>
                </thead>
                <tbody>
"""

    # 添加成功分析的行
    for analysis in successful_analyses:
        html_content += f"""
                    <tr class="success-row">
                        <td><strong>{analysis['date']}</strong></td>
                        <td><span style="color: green;">✅ 成功</span></td>
                        <td>{analysis['stock_count']} 只</td>
                        <td>{analysis['chart_count']} 个</td>
                        <td><a href="{analysis['html_file']}" class="file-link" target="_blank">📊 查看报告</a></td>
                        <td><a href="{analysis['csv_file']}" class="file-link">📄 下载CSV</a></td>
                        <td>{'📈 ' + analysis['chart_dir'] if analysis['chart_dir'] else '无图表'}</td>
                    </tr>
"""

    # 添加失败分析的行
    for analysis in failed_analyses:
        html_content += f"""
                    <tr class="failed-row">
                        <td><strong>{analysis['date']}</strong></td>
                        <td><span style="color: red;">❌ 失败</span></td>
                        <td>-</td>
                        <td>-</td>
                        <td>-</td>
                        <td>-</td>
                        <td>{analysis['reason']}</td>
                    </tr>
"""

    html_content += f"""
                </tbody>
            </table>
        </div>

        <div class="summary-section">
            <h3>📈 统计摘要</h3>
            <p><strong>分析周期：</strong>{start_date} - {end_date}</p>
            <p><strong>平均每日筛选股票数：</strong>{total_stocks / len(successful_analyses):.1f} 只</p>
            <p><strong>平均每日生成图表数：</strong>{total_charts / len(successful_analyses):.1f} 个</p>
            <p><strong>数据质量：</strong>使用前复权数据，包含60日最大盈利分析</p>
            <p><strong>技术指标：</strong>TD序列、四维结构分析、顶底结构分析</p>
        </div>

        <div class="summary-section">
            <h3>⚠️ 使用说明</h3>
            <p>• 点击"📊 查看报告"可打开对应日期的详细分析报告</p>
            <p>• 点击"📄 下载CSV"可下载原始筛选数据</p>
            <p>• 图表目录包含该日期重点关注股票的K线技术图表</p>
            <p>• 建议重点关注连续多日出现的强势股票</p>
            <p>• 所有分析基于历史数据，不构成投资建议</p>
        </div>
    </div>
</body>
</html>
"""

    return html_content


# 主程序
if __name__ == "__main__":
    # 过滤matplotlib和tkinter相关警告
    import warnings

    warnings.filterwarnings('ignore', category=UserWarning, module='matplotlib')
    warnings.filterwarnings('ignore', category=RuntimeWarning, module='matplotlib')
    warnings.filterwarnings('ignore', message='.*main thread is not in main loop.*')

    try:
        print("=" * 80)
        print("增强版TD股票分析系统 - 指定股票代码分析版本")
        print("=" * 80)
        print("\n🆕 功能说明：")
        print("✅ 输入指定股票代码进行专业TD技术分析")
        print("✅ 支持多个股票代码同时分析")
        print("✅ 全面前复权数据处理")
        print("✅ 四维结构分析 + 顶底结构分析")
        print("✅ 专业情绪分析（8大指标）")
        print("✅ 60日最大盈利计算")
        print("✅ 智能排序 + K线图表 + 雪球跳转")
        print("=" * 80)

        print("\n📊 支持的分析功能：")
        print("1. 🔢 TD序列分析（Setup + Countdown + Combo）")
        print("2. 🎯 四维结构分析（时间、价格、成交量、空间）")
        print("3. 🔺 顶底结构识别（双顶双底、头肩形态等）")
        print("4. 🎭 专业情绪分析（RSI、MACD、KDJ等8大指标）")
        print("5. 💰 60日最大盈利计算（基于前复权数据）")
        print("6. 📈 专业K线图表生成")
        print("7. 🔗 一键跳转雪球查看详情")
        print("=" * 80)

        print("\n请选择分析模式：")
        print("1. 单日分析 - 分析指定股票在指定日期的表现")
        print("2. 批量日期分析 - 分析指定股票在日期区间内的表现")

        mode_input = input("\n请选择模式(1/2，直接按回车默认选择1): ").strip()

        if mode_input == "2":
            # 批量日期分析模式
            print("\n=== 批量日期分析模式 ===")
            print("将分析指定股票在日期区间内所有交易日的表现")

            # 输入股票代码
            print("\n请输入股票代码：")
            print("支持格式：")
            print("- 带后缀：000001.SZ, 600000.SH")
            print("- 不带后缀：000001, 600000 (系统自动识别交易所)")
            print("- 多个代码用逗号分隔：000001,600000,000002")

            stock_input = input("\n请输入股票代码: ").strip()

            if not stock_input:
                print("\n❌ 股票代码不能为空！")
                input("按回车键退出...")
                exit(1)

            # 解析股票代码
            input_codes = [code.strip() for code in stock_input.split(',') if code.strip()]
            stock_codes = normalize_stock_codes(input_codes)

            if not stock_codes:
                print("\n❌ 没有有效的股票代码！")
                input("按回车键退出...")
                exit(1)

            print(f"\n✅ 将分析以下股票: {', '.join(stock_codes)}")

            # 输入日期区间
            start_date_input = input("\n请输入开始日期（格式：YYYYMMDD，例如：20250101）: ").strip()
            end_date_input = input("请输入结束日期（格式：YYYYMMDD，例如：20250710）: ").strip()

            # 验证日期格式
            if not start_date_input or not end_date_input:
                print("\n❌ 日期不能为空！")
                input("按回车键退出...")
                exit(1)

            if len(start_date_input) != 8 or not start_date_input.isdigit() or len(
                    end_date_input) != 8 or not end_date_input.isdigit():
                print("\n❌ 日期格式错误！请使用YYYYMMDD格式")
                input("按回车键退出...")
                exit(1)

            # 检查日期是否合理
            try:
                start_date_obj = pd.to_datetime(start_date_input)
                end_date_obj = pd.to_datetime(end_date_input)

                if start_date_obj > end_date_obj:
                    print("\n❌ 开始日期不能晚于结束日期！")
                    input("按回车键退出...")
                    exit(1)

                if end_date_obj > pd.Timestamp.now():
                    print("\n❌ 不能选择未来的日期！")
                    input("按回车键退出...")
                    exit(1)
            except:
                print("\n❌ 日期格式错误！")
                input("按回车键退出...")
                exit(1)

            # 执行批量日期分析
            batch_analyze_specified_stocks(stock_codes, start_date_input, end_date_input)

        else:
            # 单日分析模式
            print("\n=== 单日分析模式 ===")

            # 输入股票代码
            print("\n请输入要分析的股票代码：")
            print("支持格式：")
            print("- 带后缀：000001.SZ, 600000.SH")
            print("- 不带后缀：000001, 600000 (系统自动识别交易所)")
            print("- 多个代码用逗号分隔：000001,600000,000002")
            print("- 示例：奇科防务(002413), 浦发银行(600000), 万科A(000002)")

            stock_input = input("\n请输入股票代码: ").strip()

            if not stock_input:
                print("\n❌ 股票代码不能为空！")
                input("按回车键退出...")
                exit(1)

            # 解析股票代码
            input_codes = [code.strip() for code in stock_input.split(',') if code.strip()]
            stock_codes = normalize_stock_codes(input_codes)

            if not stock_codes:
                print("\n❌ 没有有效的股票代码！")
                input("按回车键退出...")
                exit(1)

            print(f"\n✅ 将分析以下股票: {', '.join(stock_codes)}")

            # 输入目标日期
            print("\n请输入目标分析日期（格式：YYYYMMDD）")
            print("例如：20240115")
            print("直接按回车使用最近交易日")

            target_date_input = input("\n请输入日期: ").strip()

            # 验证日期格式（如果输入了日期）
            if target_date_input:
                # 检查日期格式是否正确
                if len(target_date_input) != 8 or not target_date_input.isdigit():
                    print("\n❌ 日期格式错误！请使用YYYYMMDD格式")
                    input("按回车键退出...")
                    exit(1)

                # 检查日期是否合理
                try:
                    date_obj = pd.to_datetime(target_date_input)
                    if date_obj > pd.Timestamp.now():
                        print("\n❌ 不能选择未来的日期！")
                        input("按回车键退出...")
                        exit(1)
                    if date_obj < pd.Timestamp('2010-01-01'):
                        print("\n❌ 日期太早，请选择2010年以后的日期！")
                        input("按回车键退出...")
                        exit(1)
                except:
                    print("\n❌ 日期格式错误！")
                    input("按回车键退出...")
                    exit(1)

                # 检查是否为交易日
                print(f"\n🔍 检查日期 {target_date_input} 是否为交易日...")
                if not check_trade_date(target_date_input):
                    print(f"\n⚠️ {target_date_input} 不是交易日！")
                    latest_date = get_latest_trade_date()
                    print(f"最近的交易日是: {latest_date}")
                    use_latest = input("\n是否使用最近的交易日？(Y/N): ").strip().upper()
                    if use_latest == 'Y':
                        target_date_input = latest_date
                    else:
                        input("按回车键退出...")
                        exit(0)

                print(f"\n✅ 目标分析日期: {target_date_input}")
                result = get_specified_stocks_data(stock_codes, target_date_input)
                selected_date = target_date_input
            else:
                print("\n🔍 使用最近交易日进行分析...")
                result = get_specified_stocks_data(stock_codes)
                selected_date = get_latest_trade_date()

            # 格式化输出结果
            format_output_specified(result)

            # 保存基础结果到CSV文件
            if len(result) > 0:
                filename = f"指定股票TD分析_{selected_date}_{datetime.now().strftime('%H%M%S')}.csv"
                result.to_csv(filename, index=False, encoding='utf-8-sig')
                print(f"\n📄 基础数据已保存到: {filename}")

                # 执行增强版TD技术分析
                print(f"\n🔄 开始进行增强版TD技术分析...")
                print("🆕 包含四维结构分析、顶底结构分析、情绪分析和60日最大盈利计算...")
                print("🚀 使用多线程并行处理...")

                # 使用并行分析
                max_workers = min(4, len(result))
                print(f"📊 使用 {max_workers} 个线程并行分析 {len(result)} 只股票...")

                analyses = analyze_stocks_parallel(result, selected_date, max_workers)

                print(f"\n✅ TD分析完成！共分析 {len(analyses)} 只股票")

                # 生成TD图表
                print("\n📊 开始生成TD技术图表...")
                chart_files, chart_dir = create_td_charts_for_specified_stocks(analyses, selected_date)

                # 生成HTML可视化报告
                print("\n🎨 生成增强版HTML报告...")
                html_content = generate_html_report(analyses, selected_date, chart_files)

                # 保存HTML报告
                html_filename = f"指定股票TD分析报告_{selected_date}_{datetime.now().strftime('%H%M%S')}.html"
                with open(html_filename, 'w', encoding='utf-8') as f:
                    f.write(html_content)

                print(f"📊 增强版HTML报告已保存: {html_filename}")

                if chart_files:
                    print(f"📈 TD图表文件夹: {chart_dir}")
                    print(f"🎯 成功生成 {len(chart_files)} 个TD技术图表")

                # 自动打开HTML报告
                try:
                    webbrowser.open(f'file://{os.path.abspath(html_filename)}')
                    print(f"\n🌐 已自动打开HTML报告：{html_filename}")
                    print("🔍 基于前复权数据的专业技术分析")
                    print("📊 包含TD序列、四维结构、情绪分析、60日最大盈利等")
                    print("🔗 支持一键跳转雪球查看详情")
                except:
                    print(f"\n❌ 无法自动打开HTML报告，请手动打开：{html_filename}")

                # 显示分析汇总
                print(f"\n🎯 分析汇总：")
                print("=" * 80)
                for stock in analyses:
                    if 'analysis' in stock and isinstance(stock['analysis'], str):
                        print(f"❌ {stock['name']} ({stock['code']}): {stock['analysis']}")
                    else:
                        max_profit_pct = stock.get('max_profit_pct', 0)
                        max_profit_days = stock.get('max_profit_days', 0)
                        profit_info = f"60日最大盈利: +{max_profit_pct}%({max_profit_days}天)" if max_profit_pct > 0 else "60日最大盈利: 无盈利"

                        print(f"📈 {stock['name']} ({stock['code']}) - 评分: {stock.get('td_score', 0)}分")
                        print(
                            f"   前复权价格: ¥{stock['current_price']:.2f} | Setup: {stock['td_setup']} | Countdown: {stock['td_countdown']}")
                        print(f"   信号: {stock['td_signal_grade']} | 操作: {stock['td_strategy']['direction']}")
                        print(f"   💰 {profit_info}")
                        print("-" * 80)

                print(f"\n🔥 重要提醒：")
                print("✅ 全程使用前复权数据，技术指标更精确")
                print("✅ 包含专业的四维结构分析和情绪分析")
                print("💰 60日最大盈利为历史数据，仅供参考")
                print("🔗 可通过HTML报告一键跳转雪球查看详情")

            else:
                print("\n❌ 未获取到有效的股票数据，请检查：")
                print("1. 股票代码是否正确")
                print("2. 目标日期是否为交易日")
                print("3. 网络连接是否正常")

        # 等待用户按键退出
        input("\n✅ 分析完成！按回车键退出程序...")

    except Exception as e:
        print(f"\n❌ 执行出错: {e}")
        print("\n请检查：")
        print("1. 股票代码格式是否正确")
        print("2. 输入的日期是否为历史交易日")
        print("3. tushare等依赖包是否已安装")
        print("4. TOKEN是否有效")
        print("5. 网络连接是否正常")
        input("\n按回车键退出程序...")
